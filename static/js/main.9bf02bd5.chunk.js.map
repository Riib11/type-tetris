{"version":3,"sources":["data/List.ts","language/Syntax.ts","data/LinkedMap.ts","language/Typing.ts","State.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["cloneList","l","case","head","tail","toArray","arr","go","push","reverse","append","typeToString","type","typeVariableIdToString","id","domain","codomain","alphabet","length","Math","floor","toString","termToString","term","variableIdToString","body","applicant","argument","holeIdToString","concatMaps","m1","m2","key","value","singleMap","contextToString","context","map","join","annotate","freshTypeVariableId","freshTypeVariable","inferVariable","extractType","Error","infer","termAnn","substitution","constraints","forEach","item","sub","unify","applySubstitution","unifyConstraints","termAnns","f","a","collectConstraints","substitutions","Map","goTypeVariableId","idNew","get","undefined","set","goType","goTermAnn","normalizeTypeVariableIds","applySubstitutionTermAnn","holeContexts","collectHoleContexts","substitute","typeNew","type1","type2","occursIn","putToString","put","update","state","transition","holeContext","inference","holeType","holeId","extractHoleType","res","transitions","putOptions","fillTerm","fillHole","enumerateHoles","e","focus","termFill","freshHoleId","freshHole","App","className","this","viewConsole","viewGoal","viewContext","viewPalette","variableViews","app","bodyView","applicantView","argumentView","onClick","setState","palleteItemViews","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9bf02bd5.chunk.js","sourcesContent":["export type List<A>\n  = { case: \"nil\" }\n  | { case: \"cons\"; head: A, tail: List<A> }\n;\n\nexport function single<A>(a: A): List<A> {\n  return {case: \"cons\", head: a, tail: {case: \"nil\"}};\n}\n\nexport function cloneList<A>(l: List<A>): List<A> {\n  switch (l.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", head: l.head, tail: cloneList(l.tail)};\n  }\n}\n\nexport function mapList<A, B>(f:(a: A) => B, l: List<A>): List<B> {\n  switch (l.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", head: f(l.head), tail: mapList(f, l.tail)}\n  }\n}\n\nexport function toArray<A>(l: List<A>): A[] {\n  let arr: A[] = [];\n  function go(l: List<A>): void {\n    switch (l.case) {\n      case \"nil\": return;\n      case \"cons\": arr.push(l.head); go(l.tail); return;\n    }\n  }\n  go(l);\n  return arr.reverse();\n}\n\nexport function append<A>(head: A, tail: List<A>): List<A> {\n  return {case: \"cons\", head, tail};\n}","// Program\n\nexport type Program = Term;\n\n// Type\n\nexport type Type\n  = { case: \"unit\"; }\n  | { case: \"variable\", id: TypeVariableId }\n  | { case: \"arrow\"; domain: Type; codomain: Type; }\n;\n\nexport function typeToString(type: Type): string {\n  switch (type.case) {\n    case \"unit\": return \"Unit\";\n    case \"variable\": return typeVariableIdToString(type.id);\n    case \"arrow\": return `(${typeToString(type.domain)} -> ${typeToString(type.codomain)})`;\n  }\n}\n\nexport function typeVariableIdToString(id: TypeVariableId): string {\n  let letter = alphabet[id % alphabet.length];\n  let suffix = id > alphabet.length ? Math.floor(id / alphabet.length).toString() : \"\";\n  return letter + suffix;\n}\n\n// Term\n\nexport type Term\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; }\n  | { case: \"abstraction\"; body: Term; }\n  | { case: \"application\"; applicant: Term; argument: Term; }\n  | { case: \"hole\"; id: HoleId }\n;\n\nexport function termToString(term: Term): string {\n  switch (term.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return variableIdToString(term.id);\n    case \"abstraction\": return `(λ ${termToString(term.body)})`;\n    case \"application\": return `(${termToString(term.applicant)} ${termToString(term.argument)})`;\n    case \"hole\": return holeIdToString(term.id);\n  }\n}\n\nexport function variableIdToString(id: VariableId): string {\n  return id.toString();\n  // let letter = alphabet[id % alphabet.length];\n  // let suffix = id > alphabet.length ? Math.floor(id / alphabet.length).toString() : \"\";\n  // return letter + suffix;\n}\n\nexport function holeIdToString(id: HoleId): string {\n  return `?${id}`;\n}\n\nexport type TermAnn\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; type: Type; }\n  | { case: \"abstraction\"; body: TermAnn; type: Type; }\n  | { case: \"application\"; applicant: TermAnn; argument: TermAnn; type: Type; }\n  | { case: \"hole\"; id: HoleId; type: Type; }\n;\n\nexport function termAnnToString(termAnn: TermAnn): string {\n  switch (termAnn.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return `(${variableIdToString(termAnn.id)}: ${typeToString(termAnn.type)})`;\n    case \"abstraction\": return `(λ ${termAnnToString(termAnn.body)}): ${typeToString(termAnn.type)}`;\n    case \"application\": return `(${termAnnToString(termAnn.applicant)} ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)}`;\n    case \"hole\": return `(${holeIdToString(termAnn.id)}: ${typeToString(termAnn.type)})`;\n  }\n}\n\nexport type HoleId = number;\nexport type VariableId = number;\nexport type TypeVariableId = number;\n\nconst alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"];","export type LinkedMap<K, V>\n  = { case: \"nil\"; }\n  | { case: \"cons\"; key: K; value: V; tail: LinkedMap<K, V> }\n\nexport function lookup<K, V>(m: LinkedMap<K, V>, k: K): V | undefined {\n  switch (m.case) {\n    case \"nil\":\n      return undefined;\n    case \"cons\":\n      if (m.key === k)\n        return m.value;\n      else\n        return lookup(m.tail, k);\n  }\n}\n\nexport function keys<K, V>(m: LinkedMap<K, V>): K[] {\n  let ks: K[] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        ks.push(m.key);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return ks;\n}\n\nexport function items<K, V>(m: LinkedMap<K, V>): [K, V][] {\n  let items: [K, V][] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        items.push([m.key, m.value]);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return items;\n}\n\nexport function filterMap<K, V>(m: LinkedMap<K, V>, f: (v: V) => boolean): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\":\n      return { case: \"nil\" };\n    case \"cons\": {\n      if (f(m.value))\n        return { \n          case: \"cons\",\n          key: m.key,\n          value: m.value,\n          tail: filterMap(m.tail, f)\n        };\n      else \n        return filterMap(m.tail, f);\n    }\n  }\n}\n\nexport function concatMaps<K, V>(m1: LinkedMap<K, V>, m2: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m1.case) {\n    case \"nil\": return m2;\n    case \"cons\": {\n      return concatMaps(m1.tail, {case: \"cons\", key: m1.key, value: m1.value, tail: m2});\n    }\n  }\n}\n\nexport function singleMap<K, V>(key: K, value: V): LinkedMap<K, V> {\n  return {case: \"cons\", key, value, tail: {case: \"nil\"}};\n}\n\nexport function cloneMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": {\n      return {case: \"cons\", key: m.key, value: m.value, tail: cloneMap(m.tail)};\n    }\n  }\n}\n\nexport function reverseMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return concatMaps(reverseMap(m.tail), singleMap(m.key, m.value));\n  }\n}\n\nexport function mapMap<K, V>(f: (k: K, v: V) => V, m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", key: m.key, value: f(m.key, m.value), tail: mapMap(f, m.tail)};\n  }\n}","import { concatMaps, items, LinkedMap, mapMap, reverseMap, singleMap } from \"../data/LinkedMap\";\nimport { append, cloneList, List, toArray } from \"../data/List\";\nimport { HoleId, Term, TermAnn, termAnnToString, Type, typeToString, TypeVariableId, typeVariableIdToString, VariableId } from \"./Syntax\";\n\nexport type Context = List<Type>;\nexport type Constraints = [Type, Type][];\nexport type Substitution = LinkedMap<TypeVariableId, Type>;\n\nexport function contextToString(context: Context): string {\n  let res: string = toArray(context).map((type, id) => `${id}: ${typeToString(type)}`).join(\", \");\n  return res;\n}\n\nexport function constraintsToString(constraints: Constraints): string {\n  return constraints.map(item => `${typeToString(item[0])} ~ ${typeToString(item[1])}`).join(\", \");\n}\n\nexport function substitutionToString(substitution: Substitution): string {\n  return items(substitution).map(item => `${typeVariableIdToString(item[0])} := ${typeToString(item[1])}`).join(\", \");\n}\n\n// TODO: During inferece, get the term variable context at hole (which needs to\n//       have unification substitutions applied to it).\nexport function annotate(term: Term): TermAnn {\n  let freshTypeVariableId = 0;\n  function freshTypeVariable(): Type {\n    let type: Type = {case: \"variable\", id: freshTypeVariableId};\n    freshTypeVariableId++;\n    return type;\n  }\n\n  function go(context: Context, term: Term): TermAnn {\n    switch (term.case) {\n      case \"unit\": {\n        return {case: \"unit\"};\n      }\n      case \"variable\": {\n        let type = inferVariable(context, term.id);\n        return {case: \"variable\", id: term.id, type};\n      }\n      case \"abstraction\": {\n        let domain: Type = freshTypeVariable();\n        let body: TermAnn = go({case: \"cons\", head: domain, tail: context}, term.body);\n        return {case: \"abstraction\", body, type: {case: \"arrow\", domain, codomain: extractType(body)}};\n      }\n      case \"application\": {\n        return {case: \"application\", applicant: go(context, term.applicant), argument: go(context, term.argument), type: freshTypeVariable()};\n      }\n      case \"hole\": {\n        let type = freshTypeVariable();\n        return {case: \"hole\", id: term.id, type};\n      }\n    };\n    throw new Error(\"impossible\")\n  }\n  return go({case: \"nil\"}, term);\n}\n\nexport function collectConstraints(termAnn: TermAnn): Constraints {\n  let termAnns: List<TermAnn> = {case: \"cons\", head: termAnn, tail: {case: \"nil\"}};\n  let constraints: List<[Type, Type]> = {case: \"nil\"};\n  function go(): void {\n    switch (termAnns.case) {\n      case \"nil\": return;\n      case \"cons\": {\n        let termAnn: TermAnn = termAnns.head;\n        switch (termAnn.case) {\n          case \"unit\": return;\n          case \"variable\": return;\n          case \"abstraction\": {\n            termAnns = append(termAnn.body, termAnns);\n            return;\n          }\n          case \"application\": {\n            let [f, a] = [extractType(termAnn.applicant), extractType(termAnn.argument)];\n            termAnns = append(termAnn.argument, termAnns);\n            termAnns = append(termAnn.applicant, termAnns);\n            constraints = append([f, {case: \"arrow\", domain: a, codomain: termAnn.type}], constraints);\n          }\n        }\n      }\n    }\n  }\n  go();\n  return toArray(constraints);\n}\n\nexport function inferVariable(context: Context, id: VariableId): Type {\n  switch (context.case) {\n    case \"nil\": throw new Error(\"variable id out-of-bounds\");\n    case \"cons\": {\n      if (id === 0)\n        return context.head;\n      else\n        return inferVariable(context.tail, id-1);\n    }\n  }\n}\n\nexport type Inference = {\n  termAnn: TermAnn,\n  type: Type,\n  substitution: Substitution,\n  holeContexts: Map<HoleId, Context>;\n}\n\nexport function infer(term: Term): Inference {\n  let termAnn: TermAnn = annotate(term);\n  // console.log(`orig termAnn: ${termAnnToString(termAnn)}`);\n  let constraints: Constraints = collectConstraints(termAnn);\n  // console.log(`constraints: ${constraintsToString(constraints)}`);\n  let substitution: Substitution = unifyConstraints(constraints);\n  // console.log(`substitution: ${substitutionToString(substitution)}`);\n  termAnn = applySubstitutionTermAnn(substitution, termAnn);\n  termAnn = normalizeTypeVariableIds(termAnn);\n  // console.log(`result termAnn: ${termAnnToString(termAnn)}`);\n  let type = extractType(termAnn);\n  let holeContexts: Map<HoleId, Context> = collectHoleContexts(termAnn);\n  return {\n    termAnn,\n    type,\n    substitution,\n    holeContexts\n  };\n}\n\nexport function applySubstitutionTermAnn(substitution: Substitution, termAnn: TermAnn): TermAnn {\n  switch (termAnn.case) {\n    case \"unit\": return termAnn;\n    case \"variable\": return {case: \"variable\", id: termAnn.id, type: applySubstitution(substitution, termAnn.type)};\n    case \"abstraction\": return {case: \"abstraction\", body: applySubstitutionTermAnn(substitution, termAnn.body), type: applySubstitution(substitution, termAnn.type)};\n    case \"application\": return {case: \"application\", applicant: applySubstitutionTermAnn(substitution, termAnn.applicant), argument: applySubstitutionTermAnn(substitution, termAnn.argument), type: applySubstitution(substitution, termAnn.type)};\n    case \"hole\": return {case: \"hole\", id: termAnn.id, type: applySubstitution(substitution, termAnn.type)};\n  }\n}\n\nexport function collectHoleContexts(termAnn: TermAnn): Map<HoleId, Context> {\n  let holeContexts: Map<HoleId, Context> = new Map();\n  function go(context: Context, termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": {\n        switch (termAnn.type.case) {\n          case \"arrow\": {\n            go({case: \"cons\", head: termAnn.type.domain, tail: context}, termAnn.body);\n            return;\n          }\n          default: {\n            throw new Error(\"impossible\");\n          }\n        }\n      }\n      case \"application\": {\n        go(context, termAnn.applicant);\n        go(context, termAnn.argument);\n        break;\n      }\n      case \"hole\": {\n        holeContexts.set(termAnn.id, cloneList(context));\n        break;\n      }\n    }\n  }\n  go({case: \"nil\"}, termAnn);\n  return holeContexts;\n}\n\nexport function substitute(id: TypeVariableId, typeNew: Type, type: Type): Type {\n  switch (type.case) {\n    case \"unit\": return type;\n    case \"variable\": {\n      if (type.id === id)\n        return typeNew;\n      else\n        return type;\n    }\n    case \"arrow\": {\n      return {\n        case: \"arrow\",\n        domain: substitute(id, typeNew, type.domain),\n        codomain: substitute(id, typeNew, type.codomain)\n      };\n    }\n  }\n}\n\nexport function applySubstitution(substitution: Substitution, type: Type): Type {\n  function go(substitution: Substitution, type: Type): Type {\n    switch (substitution.case) {\n      case \"nil\": return type;\n      case \"cons\": {\n        type = applySubstitution(substitution.tail, type);\n        type = substitute(substitution.key, substitution.value, type);\n        return type;\n      }\n    }\n  }\n  return go(substitution, type);;\n}\n\nexport function unifyConstraints(constraints: Constraints): Substitution {\n  let substitution: Substitution = {case: \"nil\"};\n  // NOTE: seems like right direction for fold\n  constraints.forEach(item => {\n    let sub = unify(applySubstitution(substitution, item[0]), applySubstitution(substitution, item[1]));\n    substitution = concatMaps(substitution, sub);\n  });\n  return substitution;\n}\n\nexport function unify(type1: Type, type2: Type): Substitution {\n  switch (type1.case) {\n    case \"unit\": {\n      switch (type2.case) {\n        case \"unit\": return {case: \"nil\"};\n        case \"variable\": return singleMap(type2.id, type1);\n        case \"arrow\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n      }\n      break;\n    }\n    case \"variable\": {\n      switch (type2.case) {\n        case \"unit\": return singleMap(type1.id, type2);\n        case \"variable\": {\n          if (type1.id === type2.id)\n            return {case: \"nil\"};\n          else\n            return singleMap(type1.id, type2);\n        }\n        case \"arrow\": {\n          if (occursIn(type1.id, type2))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type1.id)}`);\n          else\n            return singleMap(type1.id, type2);\n        }\n      }\n      break;\n    }\n    case \"arrow\": {\n      switch (type2.case) {\n        case \"unit\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n        case \"variable\": {\n          if (occursIn(type2.id, type2))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type2.id)}`);\n          else\n            return singleMap(type2.id, type1);\n        }\n        case \"arrow\": {\n          return concatMaps(\n            unify(type1.domain, type2.domain),\n            unify(type2.codomain, type1.codomain));\n        }\n      }\n      break;\n    }\n  }\n  throw new Error(\"impossible\");\n}\n\n// Checks if `id` occurs in `type`\nexport function occursIn(id: TypeVariableId, type: Type): boolean {\n  switch (type.case) {\n    case \"unit\": return false;\n    case \"variable\": return id === type.id;\n    case \"arrow\": return occursIn(id, type.domain) || occursIn(id, type.codomain);\n  }\n}\n\nexport function extractType(term: TermAnn): Type {\n  switch (term.case) {\n    case \"unit\": return {case: \"unit\"};\n    case \"variable\": return term.type;\n    case \"abstraction\": return term.type;\n    case \"application\": return term.type;\n    case \"hole\": return term.type;\n  }\n}\n\nexport function extractHoleType(termAnn: TermAnn, holeId: HoleId): Type {\n  let type: Type | undefined = undefined;\n  function go(termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": go(termAnn.body); return;\n      case \"application\": go(termAnn.applicant); go(termAnn.argument); return;\n      case \"hole\": {\n        if (termAnn.id === holeId)\n          type = termAnn.type;\n      }\n    }\n  }\n  go(termAnn);\n  if (type !== undefined)\n    return type;\n  else\n    throw new Error(`hole id ${holeId} not found`);\n}\n\nexport function normalizeTypeVariableIds(termAnn: TermAnn): TermAnn {\n  let substitutions: Map<TypeVariableId, TypeVariableId> = new Map();\n  let freshTypeVariableId = 0;\n\n  function goTypeVariableId(id: TypeVariableId): TypeVariableId {\n    let idNew = substitutions.get(id);\n    if (idNew !== undefined)\n      return idNew;\n    else {\n      substitutions.set(id, freshTypeVariableId);\n      idNew = freshTypeVariableId;\n      freshTypeVariableId++;\n      return idNew;\n    }\n  }\n  \n  function goType(type: Type): Type {\n    switch (type.case) {\n      case \"unit\": return {case: \"unit\"};\n      case \"variable\": return {case: \"variable\", id: goTypeVariableId(type.id)};\n      case \"arrow\": return {case: \"arrow\", domain: goType(type.domain), codomain: goType(type.codomain)};\n    }\n  }\n\n  function goTermAnn(termAnn: TermAnn): TermAnn {\n    switch (termAnn.case) {\n      case \"unit\": return {case: \"unit\"};\n      case \"variable\": return {case: \"variable\", id: termAnn.id, type: goType(termAnn.type)};\n      case \"abstraction\": return {case: \"abstraction\", body: goTermAnn(termAnn.body), type: goType(termAnn.type)};\n      case \"application\": return {case: \"application\", applicant: goTermAnn(termAnn.applicant), argument: goTermAnn(termAnn.argument), type: goType(termAnn.type)};\n      case \"hole\": return {case: \"hole\", id: termAnn.id, type: goType(termAnn.type)};\n    }\n  }\n\n  return goTermAnn(termAnn);\n}\n\n// TODO: pretty sure I don't need this anymore\n// export function collectTypeVariableIds(termAnn: TermAnn): TypeVariableId[] {\n//   let ids: TypeVariableId[] = [];\n\n//   function goType(type: Type): void {\n//     switch (type.case) {\n//       case \"unit\": return;\n//       case \"variable\": {\n//         ids.push(type.id);\n//         return;\n//       }\n//       case \"arrow\": {\n//         goType(type.domain);\n//         goType(type.codomain);\n//         return;\n//       }\n//     }\n//   }\n\n//   function goTermAnn(termAnn: TermAnn): void {\n//     switch (termAnn.case) {\n//       case \"unit\": return;\n//       case \"variable\": {\n//         goType(termAnn.type);\n//         return;\n//       }\n//       case \"abstraction\": {\n//         goType(termAnn.type);\n//         goTermAnn(termAnn.body);\n//         return;\n//       }\n//       case \"application\": {\n//         goType(termAnn.type);\n//         goTermAnn(termAnn.applicant);\n//         goTermAnn(termAnn.argument);\n//         return;\n//       }\n//       case \"hole\": {\n//         goType(termAnn.type);\n//         return;\n//       }\n//     }\n//   }\n\n//   goTermAnn(termAnn);\n//   return ids;\n// }","import { toArray } from \"./data/List\";\nimport { HoleId, holeIdToString, Term, termAnnToString, termToString, Type, typeToString, VariableId, variableIdToString } from \"./language/Syntax\";\nimport { collectHoleContexts, Context, contextToString, infer, Inference, extractHoleType } from \"./language/Typing\";\n\nexport type State = {\n  term: Term;\n  type: Type;\n  focus: Focus | undefined;\n};\n\nexport type Focus = {\n  id: HoleId;\n  type: Type;\n  context: Context;\n  transitions: Transition[]; \n}\n\nexport type Transition\n  = { case: \"select\"; id: HoleId; }\n  | { case: \"put\"; put: Put }\n;\n\nexport type Put\n  = { case: \"unit\" }\n  | { case: \"variable\"; id: VariableId }\n  | { case: \"abstraction\" }\n  | { case: \"application\" }\n\nexport function stateToString(state: State): string {\n  return `term: ${termToString(state.term)}; type: ${typeToString(state.type)}; focus: ${focusToString(state.focus)}`;\n}\n\nexport function focusToString(focus: Focus | undefined): string {\n  if (focus !== undefined) {\n    return `id: ${focus.id}; type: ${typeToString(focus.type)}; context: ${contextToString(focus.context)}; transitions: ${focus.transitions.map(t => transitionToString(t)).join(\", \")}`;\n  } else \n    return \"unfocussed\"\n}\n\nexport function transitionToString(transition: Transition): string {\n  switch (transition.case) {\n    case \"select\": {\n      return `select hole id ${transition.id}`;\n    }\n    case \"put\": {\n      return `put ${putToString(transition.put)}`;\n    }\n  }\n}\n\nexport function putToString(put: Put): string {\n  switch (put.case) {\n    case \"unit\": return `unit`;\n    case \"variable\": return variableIdToString(put.id);\n    case \"abstraction\": return `λ ?`;\n    case \"application\": return `? ?`;\n  }\n}\n\n// Update\n\nexport function update(state: State, transition: Transition): State {\n  switch (transition.case) {\n    case \"select\": {\n      // Infer hole type and context\n      let inference: Inference = infer(state.term);\n      let holeType: Type = extractHoleType(inference.termAnn, transition.id);\n      let holeContexts: Map<HoleId, Context> = collectHoleContexts(inference.termAnn);\n      {\n        let arr: string[] = [];\n        holeContexts.forEach((context, id) => arr.push(`${holeIdToString(id)}: ${contextToString(context)}`));\n      }\n      let holeContext: Context;\n      {\n        let res = holeContexts.get(transition.id);\n        if (res !== undefined)\n          holeContext = res;\n        else {\n          throw new Error(`hole id ${transition.id} not found among hole contexts`);\n        }\n      }\n\n      // Collect transitions\n      let transitions: Transition[] = [];\n      let putOptions: Put[] = [];\n      // Basic constructors\n      putOptions.push({case: \"unit\"});\n      putOptions.push({case: \"application\"});\n      putOptions.push({case: \"abstraction\"});\n      // Variable constructors\n      toArray(holeContext).forEach((type, id) =>\n        putOptions.push({case: \"variable\", id})\n      );\n      putOptions.forEach(put => {\n        let fillTerm: Term;\n        switch (put.case) {\n          case \"unit\": fillTerm = {case: \"unit\"}; break;\n          case \"variable\": fillTerm = {case: \"variable\", id: put.id}; break;\n          case \"abstraction\": fillTerm = {case: \"abstraction\", body: {case: \"hole\", id: -1}}; break;\n          case \"application\": fillTerm = {case: \"application\", applicant: {case: \"hole\", id: -1}, argument: {case: \"hole\", id: -1}}; break;\n        }\n        let term: Term = fillHole(state.term, transition.id, fillTerm);\n        term = enumerateHoles(term);\n        try {\n          infer(term);\n          // if succeeds, then add\n          transitions.push({case: \"put\", put});\n        } catch (e) {\n          // pass\n        }\n      });\n\n      // New state\n      return {\n        term: state.term,\n        type: inference.type,\n        focus: {\n          id: transition.id,\n          type: holeType,\n          context: holeContext,\n          transitions\n        }\n      };\n    }\n    case \"put\": {\n      // must have focus in order to \"put\"\n      let focus: Focus = state.focus as Focus;\n      let fillTerm: Term;\n      switch (transition.put.case) {\n        case \"unit\": fillTerm = {case: \"unit\"}; break;\n        case \"variable\": fillTerm = {case: \"variable\", id: transition.put.id}; break;\n        case \"abstraction\": fillTerm = {case: \"abstraction\", body: {case: \"hole\", id: -1}}; break;\n        case \"application\": fillTerm = {case: \"application\", applicant: {case: \"hole\", id: -1}, argument: {case: \"hole\", id: -1}}; break;\n      }\n      let term: Term = fillHole(state.term, focus.id, fillTerm);\n      term = enumerateHoles(term);\n      let inference: Inference = infer(term);\n      return {\n        term,\n        type: inference.type,\n        focus: undefined,\n      };\n    }\n  }\n\n  throw new Error(\"unimplemented\");\n}\n\nexport function fillHole(term: Term, id:HoleId, termFill: Term): Term {\n  switch (term.case) {\n    case \"unit\": return term;\n    case \"variable\": return term;\n    case \"abstraction\": return {case: \"abstraction\", body: fillHole(term.body, id, termFill)};\n    case \"application\": return {case: \"application\", applicant: fillHole(term.applicant, id, termFill), argument: fillHole(term.argument, id, termFill)};\n    case \"hole\": {\n      if (term.id === id)\n        return termFill;\n      else \n        return term;\n    }\n  }\n}\n\nexport function enumerateHoles(term: Term): Term {\n  let freshHoleId = 0;\n  function freshHole(): Term {\n    let term: Term = {case: \"hole\", id: freshHoleId};\n    freshHoleId++;\n    return term;\n  }\n  function go(term: Term): Term {\n    switch (term.case) {\n      case \"unit\": return term;\n      case \"variable\": return term;\n      case \"abstraction\": return {case: \"abstraction\", body: go(term.body)};\n      case \"application\": return {case: \"application\", applicant: go(term.applicant), argument: go(term.argument)};\n      case \"hole\": return freshHole();\n    }\n  }\n  return go(term);\n}","import React, { MouseEventHandler } from 'react';\nimport './App.css';\nimport { toArray } from './data/List';\nimport { holeIdToString, Term, termToString, typeToString, variableIdToString } from './language/Syntax';\nimport { putToString, State, update } from './State';\n\nexport type AppProperties = {};\n\nexport default class App extends React.Component<AppProperties, State> {\n  state: State = {\n    term: {case: \"hole\", id: 0},\n    type: {case: \"variable\", id: 0},\n    focus: undefined\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        {this.viewConsole()}\n        <hr />\n        {this.viewGoal()}\n        <hr />\n        {this.viewContext()}\n        <hr />\n        {this.viewPalette()}\n      </div>\n    );\n  }\n  \n  viewContext(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let variableViews: JSX.Element[] = [];\n      toArray(this.state.focus.context).forEach((type, id) =>\n        variableViews.push(\n          <div className=\"context-variable\">\n            {variableIdToString(id)}: {typeToString(type)}\n          </div>)\n      );\n      return (\n        <div className=\"context\">\n          Context: {variableViews}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewGoal(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"goal\">\n          Goal: {typeToString(this.state.focus.type)}\n        </div>\n      );\n    } else\n    return (<div></div>);\n  }\n  \n  viewConsole(): JSX.Element {\n    let app = this;\n    function go(term: Term): JSX.Element {\n      switch (term.case) {\n        case \"unit\": return <span>{termToString(term)}</span>;\n        case \"variable\": return <span>{termToString(term)}</span>;\n        case \"abstraction\": {\n          let bodyView = go(term.body);\n          return (<span>(λ {bodyView})</span>);\n        }\n        case \"application\": {\n          let applicantView = go(term.applicant);\n          let argumentView = go(term.argument);\n          return (<span>({applicantView} {argumentView})</span>);\n        }\n        case \"hole\": {\n          let onClick: MouseEventHandler = e => app.setState(update(app.state, {case: \"select\", id: term.id}));\n          let className = app.state.focus !== undefined && app.state.focus.id === term.id ? \"hole focussed\" : \"hole\";\n          return (<span className={className} onClick={onClick}>{holeIdToString(term.id)}</span>);\n        }\n      }\n    }\n    return (\n      <div className=\"console\">\n        {go(this.state.term)} : {typeToString(this.state.type)}\n      </div>\n    )\n  }\n  \n  viewPalette(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let app = this;\n      let palleteItemViews: JSX.Element[] = [];\n\n      this.state.focus.transitions.forEach((transition) => {\n        switch (transition.case) {\n          case \"select\": break;\n          case \"put\": {\n            let onClick: MouseEventHandler = e => app.setState(update(app.state, transition));\n            palleteItemViews.push(\n              <div className=\"palette-item\" onClick={onClick}>\n                {putToString(transition.put)}\n              </div>\n            );\n          }\n        }\n      })\n      return (\n        <div className=\"palette\">\n          {palleteItemViews}\n        </div>\n      );\n    } else {\n      return (<div></div>);\n    }\n    \n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}