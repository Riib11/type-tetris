{"version":3,"sources":["data/LinkedMap.ts","data/Alphabet.ts","language/Syntax.ts","language/Unification.ts","language/Typing.ts","State.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["lookup","m","k","eq","undefined","k1","k2","case","key","value","tail","appendMap","v","items","go","push","concatMaps","m1","m2","singleMap","cloneMap","alphabet","typeToString","type","typeVariableNameToString","name","domain","codomain","part1","part2","letter","id","length","suffix","Math","floor","toString","termToString","term","variableNameToString","body","applicant","argument","proj1","proj2","holeNameToString","label","termAnnToString","termAnn","extractType","collectTypeVariableNames","names","collectTypes","forEach","types","enumerateTypeVariableNames","console","log","reverse","includes","enumerateHoles","freshHoleId","holeNames","collectHoleNames","constraintsToString","constraints","map","item","join","unifyConstraints","sub","subNew","unify","applySubstitution","type1","type2","errorUnification","checkCircularity","Error","occursIn","applySubstitutionTermAnn","substitute","typeNew","contextToString","context","infer","inferVariable","annotate","termAnns","pop","arrow","calculateConstraints","substitution","holeContexts","Map","set","collectHoleContexts","holeTypes","collectHoleTypes","putToString","put","update","state","transition","inference","holeContext","holeName","get","getHoleContext","holeType","getHoleType","transitions","putOptions","fillTerm","generateFillTerm","fillHole","e","focus","relabel","termFill","App","className","this","viewConsole","viewEnvironment","viewPalette","viewContext","viewGoal","variableViews","app","bodyView","varValue","varView","onChange","elem","target","style","width","setState","applicantView","argumentView","part1View","part2View","onClick","palleteItemViews","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.77c551b2.chunk.js","sourcesContent":["export type LinkedMap<K, V>\n  = { case: \"nil\"; }\n  | { case: \"cons\"; key: K; value: V; tail: LinkedMap<K, V> }\n\nexport function nilMap<K, V>(): LinkedMap<K, V> {\n  return {case: \"nil\"};\n}\n\nexport function lookup<K, V>(m: LinkedMap<K, V>, k: K, eq?: (k1: K, k2: K) => boolean): V | undefined {\n  if (eq === undefined)\n    eq = (k1, k2) => (k1 === k2);\n  switch (m.case) {\n    case \"nil\":\n      return undefined;\n    case \"cons\":\n      if (m.key === k)\n        return m.value;\n      else\n        return lookup(m.tail, k, eq);\n  }\n}\n\nexport function appendMap<K, V>(k: K, v: V, m: LinkedMap<K, V>): LinkedMap<K, V> {\n  return {case: \"cons\", key: k, value: v, tail: m};\n}\n\nexport function keys<K, V>(m: LinkedMap<K, V>): K[] {\n  let ks: K[] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        ks.push(m.key);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return ks;\n}\n\nexport function items<K, V>(m: LinkedMap<K, V>): [K, V][] {\n  let items: [K, V][] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        items.push([m.key, m.value]);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return items;\n}\n\nexport function filterMap<K, V>(m: LinkedMap<K, V>, f: (v: V) => boolean): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\":\n      return { case: \"nil\" };\n    case \"cons\": {\n      if (f(m.value))\n        return { \n          case: \"cons\",\n          key: m.key,\n          value: m.value,\n          tail: filterMap(m.tail, f)\n        };\n      else \n        return filterMap(m.tail, f);\n    }\n  }\n}\n\nexport function concatMaps<K, V>(m1: LinkedMap<K, V>, m2: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m1.case) {\n    case \"nil\": return m2;\n    case \"cons\": {\n      return concatMaps(m1.tail, {case: \"cons\", key: m1.key, value: m1.value, tail: m2});\n    }\n  }\n}\n\nexport function singleMap<K, V>(key: K, value: V): LinkedMap<K, V> {\n  return {case: \"cons\", key, value, tail: {case: \"nil\"}};\n}\n\nexport function cloneMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": {\n      return {case: \"cons\", key: m.key, value: m.value, tail: cloneMap(m.tail)};\n    }\n  }\n}\n\nexport function reverseMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return concatMaps(reverseMap(m.tail), singleMap(m.key, m.value));\n  }\n}\n\nexport function mapMap<K, V>(f: (k: K, v: V) => V, m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", key: m.key, value: f(m.key, m.value), tail: mapMap(f, m.tail)};\n  }\n}","export const alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"];","import { alphabet } from \"../data/Alphabet\";\n\n// Types\n\nexport type HoleName = {id: HoleId};\nexport type HoleId = number;\n\nexport type VariableName = {label: VariableLabel};\nexport type VariableLabel = string;\n\nexport type TypeVariableName = {id: TypeVariableId};\nexport type TypeVariableId = number;\n\n// Type\n\nexport type Type\n  = { case: \"unit\"; }\n  | { case: \"variable\", name: TypeVariableName }\n  | { case: \"arrow\"; domain: Type; codomain: Type; }\n  | { case: \"product\", part1: Type; part2: Type; }\n;\n\nexport function typeToString(type: Type): string {\n  switch (type.case) {\n    case \"unit\": return \"Unit\";\n    case \"variable\": return typeVariableNameToString(type.name);\n    case \"arrow\": return `(${typeToString(type.domain)} → ${typeToString(type.codomain)})`;\n    case \"product\": return `(${typeToString(type.part1)} × ${typeToString(type.part2)})`;\n  }\n}\n\nexport function typeVariableNameToString(name: TypeVariableName): string {\n  let letter = alphabet[name.id % alphabet.length];\n  let suffix = name.id > alphabet.length ? Math.floor(name.id / alphabet.length).toString() : \"\";\n  return `${letter}${suffix}`;\n}\n\n// Term\n\nexport type Term\n  = { case: \"unit\"; }\n  | { case: \"variable\"; name: VariableName; }\n  | { case: \"abstraction\"; name: VariableName; body: Term; }\n  | { case: \"application\"; applicant: Term; argument: Term; }\n  | { case: \"pair\"; proj1: Term; proj2: Term; }\n  | { case: \"proj1\"; argument: Term; }\n  | { case: \"proj2\"; argument: Term; }\n  | { case: \"hole\"; name: HoleName }\n;\n\nexport function termToString(term: Term): string {\n  switch (term.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return variableNameToString(term.name);\n    case \"abstraction\": return `(λ ${variableNameToString(term.name)} . ${termToString(term.body)})`;\n    case \"application\": return `(${termToString(term.applicant)} ${termToString(term.argument)})`;\n    case \"pair\": return `(${termToString(term.proj1)}, ${termToString(term.proj2)})`;\n    case \"proj1\": return `(π₁ ${termToString(term.argument)})`;\n    case \"proj2\": return `(π₂ ${termToString(term.argument)})`;\n    case \"hole\": return holeNameToString(term.name);\n  }\n}\n\nexport function variableNameToString(name: VariableName): string {\n  return `${name.label}`;\n}\n\nexport function holeNameToString(name: HoleName): string {\n  return `?${name.id}`;\n}\n\n// Term with type-annotations\nexport type TermAnn\n  = { case: \"unit\"; }\n  | { case: \"variable\"; name: VariableName; type: Type; }\n  | { case: \"abstraction\"; name: VariableName; body: TermAnn; type: Type; }\n  | { case: \"application\"; applicant: TermAnn; argument: TermAnn; type: Type; }\n  | { case: \"proj1\"; argument: TermAnn; type: Type; part2: Type; }\n  | { case: \"proj2\"; argument: TermAnn; type: Type; part1: Type; }\n  | { case: \"pair\"; proj1: TermAnn; proj2: TermAnn; type: Type }\n  | { case: \"hole\"; name: HoleName; type: Type; }\n;\n\nexport function termAnnToString(termAnn: TermAnn): string {\n  switch (termAnn.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return `(${variableNameToString(termAnn.name)}: ${typeToString(termAnn.type)})`;\n    case \"abstraction\": return `(λ ${variableNameToString(termAnn.name)} . ${termAnnToString(termAnn.body)}): ${typeToString(termAnn.type)}`;\n    case \"application\": return `(${termAnnToString(termAnn.applicant)} ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)}`;\n    case \"pair\": return `(${termAnnToString(termAnn.proj1)}, ${termAnnToString(termAnn.proj2)}): ${typeToString(termAnn.type)}`;\n    case \"proj1\": return `(π₁ ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)} (* ${typeToString(termAnn.part2)})`;\n    case \"proj2\": return `(π₂ ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)} (${typeToString(termAnn.part1)} *)`;\n    case \"hole\": return `(${holeNameToString(termAnn.name)}: ${typeToString(termAnn.type)})`;\n  }\n}\n\n// Extractions\n\nexport function extractType(termAnn: TermAnn): Type {\n  switch (termAnn.case) {\n    case \"unit\": return {case: \"unit\"};\n    case \"variable\": return termAnn.type;\n    case \"abstraction\": return termAnn.type;\n    case \"application\": return termAnn.type;\n    case \"pair\": return termAnn.type;\n    case \"proj1\": return termAnn.type;\n    case \"proj2\": return termAnn.type;\n    case \"hole\": return termAnn.type;\n  }\n}\n\n// Collections\n\nexport function collectTypeVariableNames(termAnn: TermAnn): TypeVariableName[] {\n  let names: TypeVariableName[] = []\n  function go(type: Type): void {\n    switch (type.case) {\n      case \"unit\": return;\n      case \"variable\": names.push(type.name); return;\n      case \"arrow\": go(type.domain); go(type.domain); return;\n      case \"product\": go(type.part1); go(type.part2); return;\n    }\n  }\n  collectTypes(termAnn).forEach(type => go(type));\n  return names;\n}\n\nexport function collectTypes(termAnn: TermAnn): Type[] {\n  let types: Type[] = [];\n  function go(termAnn: TermAnn) {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": types.push(termAnn.type); return;\n      case \"abstraction\": types.push(termAnn.type); go(termAnn.body); return;\n      case \"application\": types.push(termAnn.type); go(termAnn.applicant); go(termAnn.argument); return;\n      case \"pair\": types.push(termAnn.type); go(termAnn.proj1); go(termAnn.proj2); return;\n      case \"proj1\": types.push(termAnn.type); types.push(termAnn.part2); go(termAnn.argument); return;\n      case \"proj2\": types.push(termAnn.type); types.push(termAnn.part1); go(termAnn.argument); return;\n      case \"hole\": types.push(termAnn.type); return;\n    }\n  }\n  go(termAnn);\n  return types;\n}\n\nexport function collectHoleTypes(termAnn: TermAnn): Map<HoleName, Type> {\n  let holeTypes: Map<HoleName, Type> = new Map();\n  function go(termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": go(termAnn.body); return;\n      case \"application\": go(termAnn.applicant); go(termAnn.argument); return;\n      case \"pair\": go(termAnn.proj1); go(termAnn.proj2); return;\n      case \"proj1\": go(termAnn.argument); return;\n      case \"proj2\": go(termAnn.argument); return;\n      case \"hole\": { holeTypes.set(termAnn.name, termAnn.type); return; }\n    }\n  }\n  go(termAnn);\n  return holeTypes;\n}\n\nexport function collectHoleNames(term: Term): HoleName[] {\n  let holeNames: HoleName[] = [];\n  function go(term: Term): void {\n    switch (term.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": go(term.body); return;\n      case \"application\": go(term.applicant); go(term.argument); return;\n      case \"pair\": go(term.proj1); go(term.proj2); return;\n      case \"proj1\": go(term.argument); return;\n      case \"proj2\": go(term.argument); return;\n      case \"hole\": { holeNames.push(term.name); return; }\n    }\n  }\n  go(term);\n  return holeNames.reverse();\n}\n\n// Fresh names\n\nexport function nextTypeVariableId(id: TypeVariableId): TypeVariableId {\n  return id + 1;\n}\n\nexport function nextTypeVariableName(name: TypeVariableName): TypeVariableName {\n  return {id: nextTypeVariableId(name.id)};\n}\n\nexport function makeFreshTypeVariableName(termAnn: TermAnn): TypeVariableName {\n  let freshTypeVariableId: TypeVariableId = 0;\n  function go(type: Type): void {\n    switch (type.case) {\n      case \"unit\": return;\n      case \"variable\": freshTypeVariableId = Math.max(freshTypeVariableId, type.name.id); return;\n      case \"arrow\": go(type.domain); go(type.codomain); return;\n      case \"product\": go(type.part1); go(type.part2); return;\n    }\n  }\n  collectTypes(termAnn).forEach(type => go(type));\n  return {id: freshTypeVariableId+1};\n}\n\nexport function makeFreshTypeVariable(termAnn: TermAnn): Type {\n  return {case: \"variable\", name: makeFreshTypeVariableName(termAnn)};\n}\n\nexport function makePlaceholderTypeVariable(): Type {\n  return {case: \"variable\", name: {id: -1}};\n}\n\nexport function makePlaceholderHole(): Term {\n  return {case: \"hole\", name: {id: -1}};\n}\n\nexport function nextHoleId(id: HoleId): HoleId {\n  return id + 1;\n}\n\nexport function nextHoleName(name: HoleName): HoleName {\n  return {id: nextHoleId(name.id)};\n}\n\nexport function makePlaceholderVariableName(): VariableName {\n  return {label: \"x\"};\n}\n\nexport function enumerateTypeVariableNames(termAnn: TermAnn): void {\n  let names: TypeVariableName[] = []\n\n  function go(name: TypeVariableName): void {\n    if (!names.includes(name)) {\n      name.id = names.length;\n      names.push(name);\n    }\n  }\n  console.log(`before enumeration: ${termAnnToString(termAnn)}`);\n  collectTypeVariableNames(termAnn).reverse().forEach(name => go(name));\n  console.log(`after enumeration: ${termAnnToString(termAnn)}`);\n}\n\nexport function enumerateHoles(term: Term): void {\n  let freshHoleId = 0;\n  function go(name: HoleName): void {\n    name.id = freshHoleId;\n    freshHoleId++;\n  }\n  collectHoleNames(term).forEach(name => go(name));\n}\n\n// Relabel\n\nexport function relabel(name: VariableName, label: VariableLabel, term: Term): void {\n  function go(term: Term): void {\n    switch (term.case) {\n      case \"unit\": return;\n      case \"variable\": if (name === term.name) {term.name.label = label;}; return;\n      case \"abstraction\": if (name === term.name) {term.name.label = label;}; go(term.body); return;\n      case \"application\": go(term.applicant); go(term.argument); return;\n      case \"pair\": go(term.proj1); go(term.proj2); return;\n      case \"proj1\": go(term.argument); return;\n      case \"proj2\": go(term.argument); return;\n      case \"hole\": return;\n    }\n  }\n  go(term);\n}\n","import { concatMaps, items, LinkedMap, nilMap, singleMap } from \"../data/LinkedMap\";\nimport { TermAnn, Type, typeToString, TypeVariableName, typeVariableNameToString } from \"./Syntax\";\n\n// Types\n\nexport type Constraints = [Type, Type][];\nexport type Substitution = LinkedMap<TypeVariableName, Type>;\n\nexport function substitutionToString(sub: Substitution): string {\n  return items(sub).map(item => `${typeVariableNameToString(item[0])} := ${typeToString(item[1])}`).join(\", \");\n}\n\nexport function constraintsToString(constraints: Constraints): string {\n  return constraints.map(item => `${typeToString(item[0])} ~ ${typeToString(item[1])}`).join(\", \");\n}\n\n// Unify constraints\n\nexport function unifyConstraints(constraints: Constraints): Substitution {\n  let sub: Substitution = {case: \"nil\"};\n  constraints.forEach(item => {\n    let subNew = unify(applySubstitution(sub, item[0]), applySubstitution(sub, item[1]));\n    sub = concatMaps(sub, subNew);\n  });\n  return sub;\n}\n\n// Unify two types\n\nexport function unify(type1: Type, type2: Type): Substitution {\n  switch (type1.case) {\n    case \"unit\": {\n      switch (type2.case) {\n        case \"unit\": return {case: \"nil\"};\n        case \"variable\": return singleMap(type2.name, type1);\n        case \"arrow\": throw errorUnification(type1, type2);;\n        case \"product\": throw errorUnification(type1, type2);;\n      }\n      break;\n    }\n    case \"variable\": {\n      switch (type2.case) {\n        case \"unit\": return singleMap(type1.name, type2);\n        case \"variable\": return (type1.name === type2.name) ? nilMap() : singleMap(type1.name, type2);\n        case \"arrow\": checkCircularity(type1.name, type2); return singleMap(type1.name, type2);\n        case \"product\": checkCircularity(type1.name, type2); return singleMap(type1.name, type2);\n      }\n      break;\n    }\n    case \"arrow\": {\n      switch (type2.case) {\n        case \"unit\": throw errorUnification(type1, type2);\n        case \"variable\": checkCircularity(type2.name, type1); return singleMap(type2.name, type1);\n        case \"arrow\": return concatMaps(unify(type1.domain, type2.domain), unify(type2.codomain, type1.codomain));\n        case \"product\": throw errorUnification(type1, type2);\n      }\n      break;\n    }\n    case \"product\": {\n      switch (type2.case) {\n        case \"unit\": throw errorUnification(type1, type2);\n        case \"variable\": checkCircularity(type2.name, type1); return singleMap(type2.name, type1);\n        case \"arrow\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n        case \"product\": return concatMaps(unify(type1.part1, type2.part1), unify(type1.part2, type2.part2));\n      }\n      break;\n    }\n  }\n  throw new Error(`impossible: ${typeToString(type1)} ~ ${typeToString(type2)}`);\n}\n\nexport function errorUnification(type1: Type, type2: Type): Error {\n  return new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n}\n\nexport function checkCircularity(name: TypeVariableName, type: Type): void {\n  if (occursIn(name, type))\n    throw new Error(`cannot unify ${typeToString({case: \"variable\", name: name})} with ${typeToString(type)} because of circularity on ${typeVariableNameToString(name)}`);\n}\n\n// Checks if `name` occurs in `type`\nexport function occursIn(name: TypeVariableName, type: Type): boolean {\n  switch (type.case) {\n    case \"unit\": return false;\n    case \"variable\": return name === type.name;\n    case \"arrow\": return occursIn(name, type.domain) || occursIn(name, type.codomain);\n    case \"product\": return occursIn(name, type.part1) || occursIn(name, type.part2);\n  }\n}\n\n// Substitution\n\nexport function applySubstitutionTermAnn(sub: Substitution, termAnn: TermAnn): TermAnn {\n  switch (termAnn.case) {\n    case \"unit\": return termAnn;\n    case \"variable\": return {case: \"variable\", name: termAnn.name, type: applySubstitution(sub, termAnn.type)};\n    case \"abstraction\": return {case: \"abstraction\", name: termAnn.name, body: applySubstitutionTermAnn(sub, termAnn.body), type: applySubstitution(sub, termAnn.type)};\n    case \"application\": return {case: \"application\", applicant: applySubstitutionTermAnn(sub, termAnn.applicant), argument: applySubstitutionTermAnn(sub, termAnn.argument), type: applySubstitution(sub, termAnn.type)};\n    case \"pair\": return {case: \"pair\", proj1: applySubstitutionTermAnn(sub, termAnn.proj1), proj2: applySubstitutionTermAnn(sub, termAnn.proj2), type: applySubstitution(sub, termAnn.type)};\n    case \"proj1\": return {case: \"proj1\", argument: applySubstitutionTermAnn(sub, termAnn.argument), type: applySubstitution(sub, termAnn.type), part2: applySubstitution(sub, termAnn.part2)};\n    case \"proj2\": return {case: \"proj2\", argument: applySubstitutionTermAnn(sub, termAnn.argument), type: applySubstitution(sub, termAnn.type), part1: applySubstitution(sub, termAnn.part1)};\n    case \"hole\": return {case: \"hole\", name: termAnn.name, type: applySubstitution(sub, termAnn.type)};\n  }\n}\n\nexport function substitute(name: TypeVariableName, typeNew: Type, type: Type): Type {\n  switch (type.case) {\n    case \"unit\": return type;\n    case \"variable\": return type.name === name ? typeNew : type;\n    case \"arrow\": return {case: \"arrow\", domain: substitute(name, typeNew, type.domain), codomain: substitute(name, typeNew, type.codomain)};\n    case \"product\": return { case: \"product\", part1: substitute(name, typeNew, type.part1), part2: substitute(name, typeNew, type.part2)};\n  }\n}\n\nexport function applySubstitution(sub: Substitution, type: Type): Type {\n  function go(sub: Substitution, type: Type): Type {\n    switch (sub.case) {\n      case \"nil\": return type;\n      case \"cons\": return substitute(sub.key, sub.value, go(sub.tail, type));\n    }\n  }\n  let typeNew = go(sub, type);\n  return typeNew;\n}","import { appendMap, cloneMap, items, LinkedMap, lookup } from \"../data/LinkedMap\";\nimport { collectHoleTypes, enumerateTypeVariableNames, extractType, HoleName, holeNameToString, makePlaceholderTypeVariable, Term, TermAnn, termAnnToString, termToString, Type, typeToString, VariableName, variableNameToString } from \"./Syntax\";\nimport { applySubstitutionTermAnn, Constraints, constraintsToString, Substitution, substitutionToString, unifyConstraints } from \"./Unification\";\n\n// Types\n\nexport type Context = LinkedMap<VariableName, Type>;\nexport type Inference = {\n  termAnn: TermAnn,\n  type: Type,\n  substitution: Substitution,\n  holeContexts: Map<HoleName, Context>;\n  holeTypes: Map<HoleName, Type>;\n}\n\nexport function contextToString(context: Context): string {\n  let res: string = items(context).map(item => `${variableNameToString(item[0])}: ${typeToString(item[1])}`).join(\", \");\n  return res;\n}\n\nexport function getHoleContext(holeName: HoleName, inference: Inference): Context {\n  let context = inference.holeContexts.get(holeName);\n  if (context !== undefined)\n    return context;\n  else\n    throw new Error(`hole ${holeNameToString(holeName)} not found in ${termAnnToString(inference.termAnn)}`);\n}\n\nexport function getHoleType(holeName: HoleName, inference: Inference): Type {\n  let type = inference.holeTypes.get(holeName);\n  if (type !== undefined)\n    return type;\n  else\n    throw new Error(`hole ${holeNameToString(holeName)} not found in ${termAnnToString(inference.termAnn)}`);\n}\n\n\n// Inference\n\nexport function infer(term: Term): Inference {\n  console.log(\"------------------------------------------------------\");\n  let termAnn: TermAnn = annotate(term);\n  console.log(`orig termAnn: ${termAnnToString(termAnn)}`);\n  let constraints: Constraints = calculateConstraints(termAnn);\n  console.log(`constraints: ${constraintsToString(constraints)}`);\n  let substitution: Substitution = unifyConstraints(constraints);\n  console.log(`substitution: ${substitutionToString(substitution)}`);\n  termAnn = applySubstitutionTermAnn(substitution, termAnn);\n  enumerateTypeVariableNames(termAnn);\n  console.log(`result termAnn: ${termAnnToString(termAnn)}`);\n  let type = extractType(termAnn);\n  let holeContexts: Map<HoleName, Context> = collectHoleContexts(termAnn);\n  let holeTypes: Map<HoleName, Type> = collectHoleTypes(termAnn);\n  return {\n    termAnn,\n    type,\n    substitution,\n    holeContexts,\n    holeTypes\n  };\n}\n\n// Annotation\n\nexport function annotate(term: Term): TermAnn {\n  console.log(`annotatingL ${termToString(term)}`);\n  function go(context: Context, term: Term): TermAnn {\n    switch (term.case) {\n      case \"unit\": return {case: \"unit\"};\n      case \"variable\": return {case: \"variable\", name: term.name, type: inferVariable(context, term.name)};\n      case \"abstraction\": {\n        let domain = makePlaceholderTypeVariable();\n        let body = go(appendMap(term.name, domain, context), term.body);\n        return {case: \"abstraction\", name: term.name, body, type: {case: \"arrow\", domain, codomain: extractType(body)}};\n      }\n      case \"application\": return {case: \"application\", applicant: go(context, term.applicant), argument: go(context, term.argument), type: makePlaceholderTypeVariable()};\n      case \"pair\": return {case: \"pair\", proj1: go(context, term.proj1), proj2: go(context, term.proj2), type: makePlaceholderTypeVariable()};\n      case \"proj1\": return {case: \"proj1\", argument: go(context, term.argument), type: makePlaceholderTypeVariable(), part2: makePlaceholderTypeVariable()};\n      case \"proj2\": return {case: \"proj2\", argument: go(context, term.argument), type: makePlaceholderTypeVariable(), part1: makePlaceholderTypeVariable()};\n      case \"hole\": return {case: \"hole\", name: term.name, type: makePlaceholderTypeVariable()};\n    };\n  }\n  let termAnn = go({case: \"nil\"}, term);\n  enumerateTypeVariableNames(termAnn);\n  return termAnn;\n}\n\nexport function calculateConstraints(termAnn: TermAnn): Constraints {\n  let termAnns: TermAnn[] = [termAnn];\n  let constraints: Constraints = [];\n  \n  // TODO: not needed because termAnn.part[1|2] -- implicit universal quantificiations\n  // let freshTypeVariableName = makeFreshTypeVariableName(termAnn);\n  // function makeFreshTypeVariable(): Type {\n  //   let type: Type = {case: \"variable\", name: freshTypeVariableName};\n  //   freshTypeVariableName = nextTypeVariableName(freshTypeVariableName);\n  //   return type;\n  // }\n\n  while (true) {\n    let termAnn = termAnns.pop();\n    if (termAnn === undefined) break;\n    switch (termAnn.case) {\n      case \"unit\": break;\n      case \"variable\": break;\n      case \"abstraction\": termAnns.push(termAnn.body); break;\n      case \"application\": {\n        let [arrow, domain] = [extractType(termAnn.applicant), extractType(termAnn.argument)];\n        termAnns.push(termAnn.argument);\n        termAnns.push(termAnn.applicant);\n        constraints.push([arrow, {case: \"arrow\", domain, codomain: extractType(termAnn)}]);\n        break;\n      }\n      case \"pair\": {\n        let [part1, part2] = [extractType(termAnn.proj1), extractType(termAnn.proj2)];\n        termAnns.push(termAnn.proj1);\n        termAnns.push(termAnn.proj2);\n        constraints.push([{case: \"product\", part1, part2} , termAnn.type]);\n        break;\n      }\n      case \"proj1\": {\n        termAnns.push(termAnn.argument);\n        constraints.push([extractType(termAnn.argument), {case: \"product\", part1: extractType(termAnn), part2: termAnn.part2}]);\n        console.log(`constraint from proj1: ${constraintsToString([[{case: \"product\", part1: extractType(termAnn), part2: termAnn.part2}, extractType(termAnn.argument)]])}`)\n        break;\n      }\n      case \"proj2\": {\n        termAnns.push(termAnn.argument);\n        constraints.push([{case: \"product\", part1: termAnn.part1, part2: extractType(termAnn)}, extractType(termAnn.argument)]);\n        console.log(`constraint from proj2: ${constraintsToString([[{case: \"product\", part1: termAnn.part1, part2: extractType(termAnn)}, extractType(termAnn.argument)]])}`)\n        break;\n      }\n      case \"hole\": break;\n      default: throw new Error(\"impossible\");\n    }\n  }\n  return constraints.reverse();\n}\n\nexport function inferVariable(context: Context, name: VariableName): Type {\n  let type = lookup(context, name);\n  if (type !== undefined)\n    return type;\n  else\n    throw new Error(`variable name ${variableNameToString(name)} not found in context ${contextToString(context)}`);\n}\n\n// Holes\n\nexport function collectHoleContexts(termAnn: TermAnn): Map<HoleName, Context> {\n  let holeContexts: Map<HoleName, Context> = new Map();\n  function go(context: Context, termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": {\n        switch (termAnn.type.case) {\n          case \"arrow\": go(appendMap(termAnn.name, termAnn.type.domain, context), termAnn.body); return;\n          default: throw new Error(\"impossible\");\n        }\n      }\n      case \"application\": go(context, termAnn.applicant); go(context, termAnn.argument); break;\n      case \"pair\": go(context, termAnn.proj1); go(context, termAnn.proj2); break;\n      case \"proj1\": go(context, termAnn.argument); return;\n      case \"proj2\": go(context, termAnn.argument); return;\n      case \"hole\": holeContexts.set(termAnn.name, cloneMap(context)); break;\n    }\n  }\n  go({case: \"nil\"}, termAnn);\n  return holeContexts;\n}\n","import { items } from \"./data/LinkedMap\";\nimport { HoleName, holeNameToString, Term, termToString, Type, typeToString, VariableName, variableNameToString, makePlaceholderHole, makePlaceholderVariableName, enumerateHoles, VariableLabel, relabel } from \"./language/Syntax\";\nimport { Context, contextToString, getHoleContext, getHoleType, infer } from \"./language/Typing\";\n\nexport type State = {\n  term: Term;\n  type: Type;\n  focus: Focus | undefined;\n};\n\nexport type Focus = {\n  name: HoleName;\n  type: Type;\n  context: Context;\n  transitions: Transition[]; \n}\n\nexport type Transition\n  = { case: \"select\"; name: HoleName; }\n  | { case: \"put\"; put: Put }\n  | { case: \"relabel\", name: VariableName, label: VariableLabel }\n;\n\nexport type Put\n  = { case: \"unit\" }\n  | { case: \"variable\"; name: VariableName }\n  | { case: \"abstraction\" }\n  | { case: \"application\" }\n  | { case: \"pair\" }\n  | { case: \"proj1\" }\n  | { case: \"proj2\" }\n\nexport function stateToString(state: State): string {\n  return `term: ${termToString(state.term)}; type: ${typeToString(state.type)}; focus: ${focusToString(state.focus)}`;\n}\n\nexport function focusToString(focus: Focus | undefined): string {\n  if (focus !== undefined) {\n    return `id: ${focus.name}; type: ${typeToString(focus.type)}; context: ${contextToString(focus.context)}; transitions: ${focus.transitions.map(t => transitionToString(t)).join(\", \")}`;\n  } else \n    return \"unfocussed\"\n}\n\nexport function transitionToString(transition: Transition): string {\n  switch (transition.case) {\n    case \"select\": return `select hole ${holeNameToString(transition.name)}`;\n    case \"put\": return `put ${putToString(transition.put)}`;\n    case \"relabel\": return `relabel ${variableNameToString(transition.name)} to ${transition.label}`;\n  }\n}\n\nexport function putToString(put: Put): string {\n  switch (put.case) {\n    case \"unit\": return `unit`;\n    case \"variable\": return variableNameToString(put.name);\n    case \"abstraction\": return `λ ?`;\n    case \"application\": return `? ?`;\n    case \"pair\": return `(? , ?)`\n    case \"proj1\": return `π₁ ?`\n    case \"proj2\": return `π₂ ?`\n  }\n}\n\n// Update\n\nexport function update(state: State, transition: Transition): State {\n  switch (transition.case) {\n    case \"select\": {\n      let inference = infer(state.term);\n      let holeContext = getHoleContext(transition.name, inference);\n      let holeType = getHoleType(transition.name, inference);\n\n      // Collect transitions\n      let transitions: Transition[] = [];\n      let putOptions: Put[] = [];\n      // Basic constructors\n      putOptions.push({case: \"unit\"});\n      putOptions.push({case: \"application\"});\n      putOptions.push({case: \"abstraction\"});\n      putOptions.push({case: \"pair\"});\n      putOptions.push({case: \"proj1\"});\n      putOptions.push({case: \"proj2\"});\n      // Variable constructors\n      items(holeContext).forEach(item =>  putOptions.push({case: \"variable\", name: item[0]}));\n      // Filter valid putOptions\n      putOptions.forEach(put => {\n        let fillTerm = generateFillTerm(put);\n        let term = fillHole(state.term, transition.name, fillTerm);\n        enumerateHoles(term);\n        try {\n          infer(term);\n          // if succeeds, then add\n          transitions.push({case: \"put\", put});\n        } catch (e) {\n          // pass\n          console.log(`failed inference: ${e}`);\n        }\n      });\n\n      // New state\n      return {\n        term: state.term,\n        type: inference.type,\n        focus: {\n          name: transition.name,\n          type: holeType,\n          context: holeContext,\n          transitions\n        }\n      };\n    }\n    case \"put\": {\n      // must have focus in order to \"put\"\n      let focus = state.focus as Focus;\n      let fillTerm = generateFillTerm(transition.put);\n      let term = fillHole(state.term, focus.name, fillTerm);\n      enumerateHoles(term);\n      let inference = infer(term);\n      return {\n        term,\n        type: inference.type,\n        focus: undefined,\n      };\n    }\n    case \"relabel\": {\n      relabel(transition.name, transition.label, state.term);\n      return {\n        term: state.term,\n        type: state.type,\n        focus: undefined\n      }\n    }\n  }\n}\n\nexport function generateFillTerm(put: Put): Term {\n  switch (put.case) {\n    case \"unit\": return {case: \"unit\"};\n    case \"variable\": return {case: \"variable\", name: put.name};\n    case \"abstraction\": return {case: \"abstraction\", name: makePlaceholderVariableName(), body: makePlaceholderHole()};\n    case \"application\": return {case: \"application\", applicant: makePlaceholderHole(), argument: makePlaceholderHole()};\n    case \"pair\": return {case: \"pair\", proj1: makePlaceholderHole(), proj2: makePlaceholderHole()};\n    case \"proj1\": return {case: \"proj1\", argument: makePlaceholderHole()};\n    case \"proj2\": return {case: \"proj2\", argument: makePlaceholderHole()};\n  }\n}\n\nexport function fillHole(term: Term, name:HoleName, termFill: Term): Term {\n  switch (term.case) {\n    case \"unit\": return term;\n    case \"variable\": return term;\n    case \"abstraction\": return {case: \"abstraction\", name: term.name, body: fillHole(term.body, name, termFill)};\n    case \"application\": return {case: \"application\", applicant: fillHole(term.applicant, name, termFill), argument: fillHole(term.argument, name, termFill)};\n    case \"pair\": return {case: \"pair\", proj1: fillHole(term.proj1, name, termFill), proj2: fillHole(term.proj2, name, termFill)};\n    case \"proj1\": return {case: \"proj1\", argument: fillHole(term.argument, name, termFill)};\n    case \"proj2\": return {case: \"proj2\", argument: fillHole(term.argument, name, termFill)};\n    case \"hole\": return term.name === name ? termFill : term;\n  }\n}\n\n","import React, { ChangeEventHandler, MouseEventHandler } from 'react';\nimport './App.css';\nimport { items } from './data/LinkedMap';\nimport { holeNameToString, Term, termToString, typeToString, variableNameToString } from './language/Syntax';\nimport { putToString, State, update } from './State';\n\nexport type AppProperties = {};\n\nexport default class App extends React.Component<AppProperties, State> {\n  state: State = {\n    term: {case: \"hole\", name: {id: 0}},\n    type: {case: \"variable\", name: {id: 0}},\n    focus: undefined\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        {this.viewConsole()}\n        {this.viewEnvironment()}\n        {this.viewPalette()}\n      </div>\n    );\n  }\n\n  viewEnvironment(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"environment\">\n          {this.viewContext()}\n          <hr/>\n          {this.viewGoal()}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewContext(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let variableViews: JSX.Element[] = [];\n      items(this.state.focus.context).forEach(item =>\n        variableViews.push(\n          <div className=\"context-variable\">\n            {variableNameToString(item[0])}: {typeToString(item[1])}\n          </div>)\n      );\n      return (\n        <div className=\"context\">\n          {variableViews}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewGoal(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"goal\">\n          {typeToString(this.state.focus.type)}\n        </div>\n      );\n    } else\n    return (<div></div>);\n  }\n  \n  viewConsole(): JSX.Element {\n    let app = this;\n    function go(term: Term): JSX.Element {\n      switch (term.case) {\n        case \"unit\": return (<span>{termToString(term)}</span>);\n        case \"variable\": return (<span>{termToString(term)}</span>);\n        case \"abstraction\": {\n          let bodyView = go(term.body);\n          let onChange: ChangeEventHandler<HTMLInputElement> = e => {\n            let elem = e.target;\n            elem.style.width = `${(elem.value.length + 1) * 8}px`;\n            app.setState(update(app.state, {case: \"relabel\", name: term.name, label: elem.value}));\n          };\n          let varValue = variableNameToString(term.name);\n          let varView = (<input className=\"variable\" type=\"text\" value={varValue} onChange={onChange} style={{width: `${(varValue.length + 1) * 8}px`}}></input>);\n          return (<span>(λ {varView} . {bodyView})</span>);\n        }\n        case \"application\": {\n          let applicantView = go(term.applicant);\n          let argumentView = go(term.argument);\n          return (<span>({applicantView} {argumentView})</span>);\n        }\n        case \"pair\": {\n          let part1View = go(term.proj1);\n          let part2View = go(term.proj2);\n          return (<span>({part1View}, {part2View})</span>);\n        }\n        case \"proj1\": {\n          let argumentView = go(term.argument);\n          return (<span>(π₁ {argumentView})</span>)\n        }\n        case \"proj2\": {\n          let argumentView = go(term.argument);\n          return (<span>(π₂ {argumentView})</span>)\n        }\n        case \"hole\": {\n          let onClick: MouseEventHandler = e => app.setState(update(app.state, {case: \"select\", name: term.name}));\n          let className = app.state.focus !== undefined && app.state.focus.name === term.name ? \"hole focussed\" : \"hole\";\n          return (<span className={className} onClick={onClick}>{holeNameToString(term.name)}</span>);\n        }\n      }\n    }\n    return (\n      <div className=\"console\">\n        {go(this.state.term)} : {typeToString(this.state.type)}\n      </div>\n    )\n  }\n  \n  viewPalette(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let app = this;\n      let palleteItemViews: JSX.Element[] = [];\n\n      this.state.focus.transitions.forEach((transition) => {\n        switch (transition.case) {\n          case \"select\": break;\n          case \"put\": {\n            let onClick: MouseEventHandler = e => app.setState(update(app.state, transition));\n            palleteItemViews.push(\n              <div>\n                <div className=\"palette-item\" onClick={onClick}>\n                  {putToString(transition.put)}\n                </div>\n              </div>\n            );\n          }\n        }\n      })\n      return (\n        <div className=\"palette\">\n          {palleteItemViews}\n        </div>\n      );\n    } else {\n      return (<div></div>);\n    }\n    \n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}