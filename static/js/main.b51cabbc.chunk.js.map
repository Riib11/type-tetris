{"version":3,"sources":["data/List.ts","language/Syntax.ts","data/LinkedMap.ts","language/Typing.ts","State.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["cloneList","l","case","head","tail","toArray","arr","go","push","reverse","append","typeToString","type","typeVariableIdToString","id","domain","codomain","part1","part2","letter","alphabet","length","suffix","Math","floor","toString","termToString","term","variableIdToString","body","applicant","argument","holeIdToString","concatMaps","m1","m2","key","value","singleMap","contextToString","context","map","join","inferVariable","Error","infer","termAnn","freshTypeVariableId","makeFreshTypeVariable","extractType","annotate","substitution","constraints","forEach","item","sub","unify","applySubstitution","unifyConstraints","termAnns","makeFreshTypeVariableId","freshTV","f","a","collectConstraints","substitutions","Map","goTypeVariableId","idNew","get","undefined","set","goType","goTermAnn","normalizeTypeVariableIds","applySubstitutionTermAnn","holeContexts","collectHoleContexts","substitute","typeNew","type1","type2","occursIn","max","types","extractTypes","putToString","put","update","state","transition","holeContext","inference","holeType","holeId","extractHoleType","res","transitions","putOptions","_","fillTerm","fillHole","enumerateHoles","e","console","log","focus","termFill","freshHoleId","freshHole","App","className","this","viewConsole","viewEnvironment","viewPalette","viewContext","viewGoal","variableViews","app","bodyView","applicantView","argumentView","part1View","part2View","onClick","setState","palleteItemViews","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b51cabbc.chunk.js","sourcesContent":["export type List<A>\n  = { case: \"nil\" }\n  | { case: \"cons\"; head: A, tail: List<A> }\n;\n\nexport function single<A>(a: A): List<A> {\n  return {case: \"cons\", head: a, tail: {case: \"nil\"}};\n}\n\nexport function cloneList<A>(l: List<A>): List<A> {\n  switch (l.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", head: l.head, tail: cloneList(l.tail)};\n  }\n}\n\nexport function mapList<A, B>(f:(a: A) => B, l: List<A>): List<B> {\n  switch (l.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", head: f(l.head), tail: mapList(f, l.tail)}\n  }\n}\n\nexport function toArray<A>(l: List<A>): A[] {\n  let arr: A[] = [];\n  function go(l: List<A>): void {\n    switch (l.case) {\n      case \"nil\": return;\n      case \"cons\": arr.push(l.head); go(l.tail); return;\n    }\n  }\n  go(l);\n  return arr.reverse();\n}\n\nexport function append<A>(head: A, tail: List<A>): List<A> {\n  return {case: \"cons\", head, tail};\n}","// Program\n\nexport type Program = Term;\n\n// Type\n\nexport type Type\n  = { case: \"unit\"; }\n  | { case: \"variable\", id: TypeVariableId }\n  | { case: \"arrow\"; domain: Type; codomain: Type; }\n  | { case: \"product\", part1: Type; part2: Type; }\n;\n\nexport function typeToString(type: Type): string {\n  switch (type.case) {\n    case \"unit\": return \"Unit\";\n    case \"variable\": return typeVariableIdToString(type.id);\n    case \"arrow\": return `(${typeToString(type.domain)} → ${typeToString(type.codomain)})`;\n    case \"product\": return `(${typeToString(type.part1)} * ${typeToString(type.part2)})`;\n  }\n}\n\nexport function typeVariableIdToString(id: TypeVariableId): string {\n  let letter = alphabet[id % alphabet.length];\n  let suffix = id > alphabet.length ? Math.floor(id / alphabet.length).toString() : \"\";\n  return `${letter}${suffix}`;\n}\n\n// Term\n\nexport type Term\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; }\n  | { case: \"abstraction\"; body: Term; }\n  | { case: \"application\"; applicant: Term; argument: Term; }\n  | { case: \"pair\"; part1: Term; part2: Term; }\n  | { case: \"proj1\"; argument: Term; }\n  | { case: \"proj2\"; argument: Term; }\n  | { case: \"hole\"; id: HoleId }\n;\n\nexport function termToString(term: Term): string {\n  switch (term.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return variableIdToString(term.id);\n    case \"abstraction\": return `(λ ${termToString(term.body)})`;\n    case \"application\": return `(${termToString(term.applicant)} ${termToString(term.argument)})`;\n    case \"pair\": return `(${termToString(term.part1)}, ${termToString(term.part2)})`;\n    case \"proj1\": return `(π₁ ${termToString(term.argument)})`;\n    case \"proj2\": return `(π₂ ${termToString(term.argument)})`;\n    case \"hole\": return holeIdToString(term.id);\n  }\n}\n\nexport function variableIdToString(id: VariableId): string {\n  return `#${id.toString()}`;\n}\n\nexport function holeIdToString(id: HoleId): string {\n  return `?${id}`;\n}\n\nexport type TermAnn\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; type: Type; }\n  | { case: \"abstraction\"; body: TermAnn; type: Type; }\n  | { case: \"application\"; applicant: TermAnn; argument: TermAnn; type: Type; }\n  | { case: \"proj1\"; argument: TermAnn; type: Type; }\n  | { case: \"proj2\"; argument: TermAnn;  type: Type; }\n  | { case: \"pair\"; part1: TermAnn; part2: TermAnn; type: Type; }\n  | { case: \"hole\"; id: HoleId; type: Type; }\n;\n\nexport function termAnnToString(termAnn: TermAnn): string {\n  switch (termAnn.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return `(${variableIdToString(termAnn.id)}: ${typeToString(termAnn.type)})`;\n    case \"abstraction\": return `(λ ${termAnnToString(termAnn.body)}): ${typeToString(termAnn.type)}`;\n    case \"application\": return `(${termAnnToString(termAnn.applicant)} ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)}`;\n    case \"pair\": return `(${termAnnToString(termAnn.part1)}, ${termAnnToString(termAnn.part2)}): ${typeToString(termAnn.type)}`;\n    case \"proj1\": return `(π₁ ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)}`;\n    case \"proj2\": return `(π₂ ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)}`;\n    case \"hole\": return `(${holeIdToString(termAnn.id)}: ${typeToString(termAnn.type)})`;\n  }\n}\n\nexport function extractTypes(termAnn: TermAnn): Type[] {\n  let types: Type[] = [];\n  function go(termAnn: TermAnn) {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": types.push(termAnn.type); return;\n      case \"abstraction\": types.push(termAnn.type); go(termAnn.body); return;\n      case \"application\": types.push(termAnn.type); go(termAnn.applicant); go(termAnn.argument); return;\n      case \"pair\": types.push(termAnn.type); go(termAnn.part1); go(termAnn.part2); return;\n      case \"proj1\": types.push(termAnn.type); go(termAnn.argument); return;\n      case \"proj2\": types.push(termAnn.type); go(termAnn.argument); return;\n      case \"hole\": types.push(termAnn.type); return;\n    }\n  }\n  go(termAnn);\n  return types;\n}\n\nexport type HoleId = number;\nexport type VariableId = number;\nexport type TypeVariableId = number;\n\nconst alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"];","export type LinkedMap<K, V>\n  = { case: \"nil\"; }\n  | { case: \"cons\"; key: K; value: V; tail: LinkedMap<K, V> }\n\nexport function lookup<K, V>(m: LinkedMap<K, V>, k: K): V | undefined {\n  switch (m.case) {\n    case \"nil\":\n      return undefined;\n    case \"cons\":\n      if (m.key === k)\n        return m.value;\n      else\n        return lookup(m.tail, k);\n  }\n}\n\nexport function keys<K, V>(m: LinkedMap<K, V>): K[] {\n  let ks: K[] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        ks.push(m.key);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return ks;\n}\n\nexport function items<K, V>(m: LinkedMap<K, V>): [K, V][] {\n  let items: [K, V][] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        items.push([m.key, m.value]);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return items;\n}\n\nexport function filterMap<K, V>(m: LinkedMap<K, V>, f: (v: V) => boolean): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\":\n      return { case: \"nil\" };\n    case \"cons\": {\n      if (f(m.value))\n        return { \n          case: \"cons\",\n          key: m.key,\n          value: m.value,\n          tail: filterMap(m.tail, f)\n        };\n      else \n        return filterMap(m.tail, f);\n    }\n  }\n}\n\nexport function concatMaps<K, V>(m1: LinkedMap<K, V>, m2: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m1.case) {\n    case \"nil\": return m2;\n    case \"cons\": {\n      return concatMaps(m1.tail, {case: \"cons\", key: m1.key, value: m1.value, tail: m2});\n    }\n  }\n}\n\nexport function singleMap<K, V>(key: K, value: V): LinkedMap<K, V> {\n  return {case: \"cons\", key, value, tail: {case: \"nil\"}};\n}\n\nexport function cloneMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": {\n      return {case: \"cons\", key: m.key, value: m.value, tail: cloneMap(m.tail)};\n    }\n  }\n}\n\nexport function reverseMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return concatMaps(reverseMap(m.tail), singleMap(m.key, m.value));\n  }\n}\n\nexport function mapMap<K, V>(f: (k: K, v: V) => V, m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", key: m.key, value: f(m.key, m.value), tail: mapMap(f, m.tail)};\n  }\n}","import { concatMaps, items, LinkedMap, mapMap, reverseMap, singleMap } from \"../data/LinkedMap\";\nimport { append, cloneList, List, toArray } from \"../data/List\";\nimport { extractTypes, HoleId, Term, TermAnn, termAnnToString, Type, typeToString, TypeVariableId, typeVariableIdToString, VariableId } from \"./Syntax\";\n\nexport type Context = List<Type>;\nexport type Constraints = [Type, Type][];\nexport type Substitution = LinkedMap<TypeVariableId, Type>;\n\nexport function contextToString(context: Context): string {\n  let res: string = toArray(context).map((type, id) => `${id}: ${typeToString(type)}`).join(\", \");\n  return res;\n}\n\nexport function constraintsToString(constraints: Constraints): string {\n  return constraints.map(item => `${typeToString(item[0])} ~ ${typeToString(item[1])}`).join(\", \");\n}\n\nexport function substitutionToString(substitution: Substitution): string {\n  return items(substitution).map(item => `${typeVariableIdToString(item[0])} := ${typeToString(item[1])}`).join(\", \");\n}\n\nexport function annotate(term: Term): TermAnn {\n  let freshTypeVariableId = 0;\n  function makeFreshTypeVariable(): Type {\n    let type: Type = {case: \"variable\", id: freshTypeVariableId};\n    freshTypeVariableId++;\n    return type;\n  }\n\n  function go(context: Context, term: Term): TermAnn {\n    switch (term.case) {\n      case \"unit\": return {case: \"unit\"};\n      case \"variable\": return {case: \"variable\", id: term.id, type: inferVariable(context, term.id)};\n      case \"abstraction\": {\n        let domain: Type = makeFreshTypeVariable();\n        let body: TermAnn = go({case: \"cons\", head: domain, tail: context}, term.body);\n        return {case: \"abstraction\", body, type: {case: \"arrow\", domain, codomain: extractType(body)}};\n      }\n      case \"application\": return {case: \"application\", applicant: go(context, term.applicant), argument: go(context, term.argument), type: makeFreshTypeVariable()};\n      case \"pair\": return {case: \"pair\", part1: go(context, term.part1), part2: go(context, term.part2), type: makeFreshTypeVariable()};\n      case \"proj1\": return {case: \"proj1\", argument: go(context, term.argument), type: makeFreshTypeVariable()};\n      case \"proj2\": return {case: \"proj2\", argument: go(context, term.argument), type: makeFreshTypeVariable()};\n      case \"hole\": return {case: \"hole\", id: term.id, type: makeFreshTypeVariable()};\n    };\n    throw new Error(\"impossible\")\n  }\n  return go({case: \"nil\"}, term);\n}\n\nexport function collectConstraints(termAnn: TermAnn): Constraints {\n  let termAnns: List<TermAnn> = {case: \"cons\", head: termAnn, tail: {case: \"nil\"}};\n  // let constraints: List<[Type, Type]> = {case: \"nil\"};\n  let constraints: Constraints = [];\n  \n  let freshTypeVariableId = makeFreshTypeVariableId(termAnn);\n  function freshTV(): Type {\n    let type: Type = {case: \"variable\", id: freshTypeVariableId};\n    freshTypeVariableId++;\n    return type;\n  }\n\n  while (termAnns.case !== \"nil\") {\n    let termAnn: TermAnn = termAnns.head;\n    termAnns = termAnns.tail;\n    switch (termAnn.case) {\n      case \"unit\": break;\n      case \"variable\": break;\n      case \"abstraction\": {\n        termAnns = append(termAnn.body, termAnns);\n        break;\n      }\n      case \"application\": {\n        let [f, a] = [extractType(termAnn.applicant), extractType(termAnn.argument)];\n        termAnns = append(termAnn.argument, termAnns);\n        termAnns = append(termAnn.applicant, termAnns);\n        constraints.push([f, {case: \"arrow\", domain: a, codomain: extractType(termAnn)}]);\n        break;\n      }\n      case \"pair\": {\n        let [part1, part2] = [extractType(termAnn.part1), extractType(termAnn.part2)];\n        termAnns = append(termAnn.part1, termAnns);\n        termAnns = append(termAnn.part2, termAnns);\n        constraints.push([{case: \"product\", part1, part2} , termAnn.type]);\n        break;\n      }\n      case \"proj1\": {\n        let part2 = freshTV();\n        termAnns = append(termAnn.argument, termAnns);\n        constraints.push([extractType(termAnn.argument), {case: \"product\", part1: extractType(termAnn), part2}]);\n        break;\n      }\n      case \"proj2\": {\n        let part1 = freshTV();\n        termAnns = append(termAnn.argument, termAnns);\n        constraints.push([extractType(termAnn.argument), {case: \"product\", part1, part2: extractType(termAnn)}]);\n        break;\n      }\n      case \"hole\": break;\n    }\n  }\n  return constraints.reverse();\n}\n\nexport function inferVariable(context: Context, id: VariableId): Type {\n  switch (context.case) {\n    case \"nil\": throw new Error(\"variable id out-of-bounds\");\n    case \"cons\": {\n      if (id === 0)\n        return context.head;\n      else\n        return inferVariable(context.tail, id-1);\n    }\n  }\n}\n\nexport type Inference = {\n  termAnn: TermAnn,\n  type: Type,\n  substitution: Substitution,\n  holeContexts: Map<HoleId, Context>;\n}\n\nexport function infer(term: Term): Inference {\n  // console.log(\"------------------------------------------------------\");\n  let termAnn: TermAnn = annotate(term);\n  // console.log(`orig termAnn: ${termAnnToString(termAnn)}`);\n  let constraints: Constraints = collectConstraints(termAnn);\n  // console.log(`constraints: ${constraintsToString(constraints)}`);\n  let substitution: Substitution = unifyConstraints(constraints);\n  // console.log(`substitution: ${substitutionToString(substitution)}`);\n  termAnn = applySubstitutionTermAnn(substitution, termAnn);\n  termAnn = normalizeTypeVariableIds(termAnn);\n  // console.log(`result termAnn: ${termAnnToString(termAnn)}`);\n  let type = extractType(termAnn);\n  let holeContexts: Map<HoleId, Context> = collectHoleContexts(termAnn);\n  return {\n    termAnn,\n    type,\n    substitution,\n    holeContexts\n  };\n}\n\nexport function applySubstitutionTermAnn(substitution: Substitution, termAnn: TermAnn): TermAnn {\n  switch (termAnn.case) {\n    case \"unit\": return termAnn;\n    case \"variable\": return {case: \"variable\", id: termAnn.id, type: applySubstitution(substitution, termAnn.type)};\n    case \"abstraction\": return {case: \"abstraction\", body: applySubstitutionTermAnn(substitution, termAnn.body), type: applySubstitution(substitution, termAnn.type)};\n    case \"application\": return {case: \"application\", applicant: applySubstitutionTermAnn(substitution, termAnn.applicant), argument: applySubstitutionTermAnn(substitution, termAnn.argument), type: applySubstitution(substitution, termAnn.type)};\n    case \"pair\": return {case: \"pair\", part1: applySubstitutionTermAnn(substitution, termAnn.part1), part2: applySubstitutionTermAnn(substitution, termAnn.part2), type: applySubstitution(substitution, termAnn.type)};\n    case \"proj1\": return {case: \"proj1\", argument: applySubstitutionTermAnn(substitution, termAnn.argument), type: applySubstitution(substitution, termAnn.type)};\n    case \"proj2\": return {case: \"proj2\", argument: applySubstitutionTermAnn(substitution, termAnn.argument), type: applySubstitution(substitution, termAnn.type)};\n    case \"hole\": return {case: \"hole\", id: termAnn.id, type: applySubstitution(substitution, termAnn.type)};\n  }\n}\n\nexport function collectHoleContexts(termAnn: TermAnn): Map<HoleId, Context> {\n  let holeContexts: Map<HoleId, Context> = new Map();\n  function go(context: Context, termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": {\n        switch (termAnn.type.case) {\n          case \"arrow\": {\n            go({case: \"cons\", head: termAnn.type.domain, tail: context}, termAnn.body);\n            return;\n          }\n          default: {\n            throw new Error(\"impossible\");\n          }\n        }\n      }\n      case \"application\": {\n        go(context, termAnn.applicant);\n        go(context, termAnn.argument);\n        break;\n      }\n      case \"pair\": {\n        go(context, termAnn.part1);\n        go(context, termAnn.part2);\n        break;\n      }\n      case \"proj1\": go(context, termAnn.argument); return;\n      case \"proj2\": go(context, termAnn.argument); return;\n      case \"hole\": holeContexts.set(termAnn.id, cloneList(context)); break;\n    }\n  }\n  go({case: \"nil\"}, termAnn);\n  return holeContexts;\n}\n\nexport function substitute(id: TypeVariableId, typeNew: Type, type: Type): Type {\n  switch (type.case) {\n    case \"unit\": return type;\n    case \"variable\": {\n      if (type.id === id)\n        return typeNew;\n      else\n        return type;\n    }\n    case \"arrow\": {\n      return {\n        case: \"arrow\",\n        domain: substitute(id, typeNew, type.domain),\n        codomain: substitute(id, typeNew, type.codomain)\n      };\n    }\n    case \"product\": {\n      return {\n        case: \"product\",\n        part1: substitute(id, typeNew, type.part1),\n        part2: substitute(id, typeNew, type.part2)\n      }\n    }\n  }\n}\n\nexport function applySubstitution(substitution: Substitution, type: Type): Type {\n  function go(substitution: Substitution, type: Type): Type {\n    switch (substitution.case) {\n      case \"nil\": return type;\n      case \"cons\": {\n        type = go(substitution.tail, type);\n        type = substitute(substitution.key, substitution.value, type);\n        return type;\n      }\n    }\n  }\n  type = go(substitution, type);\n  return type;\n}\n\nexport function unifyConstraints(constraints: Constraints): Substitution {\n  let substitution: Substitution = {case: \"nil\"};\n  constraints.forEach(item => {\n    let sub = unify(applySubstitution(substitution, item[0]), applySubstitution(substitution, item[1]));\n    substitution = concatMaps(substitution, sub);\n  });\n  return substitution;\n}\n\nexport function unify(type1: Type, type2: Type): Substitution {\n  switch (type1.case) {\n    case \"unit\": {\n      switch (type2.case) {\n        case \"unit\": return {case: \"nil\"};\n        case \"variable\": return singleMap(type2.id, type1);\n        case \"arrow\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n        case \"product\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n      }\n      break;\n    }\n    case \"variable\": {\n      switch (type2.case) {\n        case \"unit\": return singleMap(type1.id, type2);\n        case \"variable\": {\n          if (type1.id === type2.id)\n            return {case: \"nil\"};\n          else\n            return singleMap(type1.id, type2);\n        }\n        case \"arrow\": {\n          if (occursIn(type1.id, type2))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type1.id)}`);\n          else\n            return singleMap(type1.id, type2);\n        }\n        case \"product\": {\n          if (occursIn(type1.id, type2))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type1.id)}`);\n          else\n            return singleMap(type1.id, type2);\n        }\n      }\n      break;\n    }\n    case \"arrow\": {\n      switch (type2.case) {\n        case \"unit\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n        case \"variable\": {\n          if (occursIn(type2.id, type1))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type2.id)}`);\n          else\n            return singleMap(type2.id, type1);\n        }\n        case \"arrow\": {\n          return concatMaps(\n            unify(type1.domain, type2.domain),\n            unify(type2.codomain, type1.codomain));\n        }\n        case \"product\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n      }\n      break;\n    }\n    case \"product\": {\n      switch (type2.case) {\n        case \"unit\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n        case \"variable\": {\n          if (occursIn(type2.id, type1))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type2.id)}`);\n          else\n            return singleMap(type2.id, type1);\n        }\n        case \"arrow\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n        case \"product\": {\n          return concatMaps(\n            unify(type1.part1, type2.part1),\n            unify(type1.part2, type2.part2));\n        }\n      }\n    }\n  }\n  throw new Error(`impossible: ${typeToString(type1)} ~ ${typeToString(type2)}`);\n}\n\n// Checks if `id` occurs in `type`\nexport function occursIn(id: TypeVariableId, type: Type): boolean {\n  switch (type.case) {\n    case \"unit\": return false;\n    case \"variable\": return id === type.id;\n    case \"arrow\": return occursIn(id, type.domain) || occursIn(id, type.codomain);\n    case \"product\": return occursIn(id, type.part1) || occursIn(id, type.part2);\n  }\n}\n\nexport function extractType(term: TermAnn): Type {\n  switch (term.case) {\n    case \"unit\": return {case: \"unit\"};\n    case \"variable\": return term.type;\n    case \"abstraction\": return term.type;\n    case \"application\": return term.type;\n    case \"pair\": return term.type;\n    case \"proj1\": return term.type;\n    case \"proj2\": return term.type;\n    case \"hole\": return term.type;\n  }\n}\n\nexport function extractHoleType(termAnn: TermAnn, holeId: HoleId): Type {\n  let type: Type | undefined = undefined;\n  function go(termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": go(termAnn.body); return;\n      case \"application\": go(termAnn.applicant); go(termAnn.argument); return;\n      case \"pair\": go(termAnn.part1); go(termAnn.part2); return;\n      case \"proj1\": go(termAnn.argument); return;\n      case \"proj2\": go(termAnn.argument); return;\n      case \"hole\": {\n        if (termAnn.id === holeId)\n          type = termAnn.type;\n      }\n    }\n  }\n  go(termAnn);\n  if (type !== undefined)\n    return type;\n  else\n    throw new Error(`hole id ${holeId} not found`);\n}\n\nexport function makeFreshTypeVariableId(termAnn: TermAnn): TypeVariableId {\n  let freshTypeVariableId = 0;\n  function go(type: Type): void {\n    switch (type.case) {\n      case \"unit\": return;\n      case \"variable\": freshTypeVariableId = Math.max(freshTypeVariableId, type.id); return;\n      case \"arrow\": go(type.domain); go(type.codomain); return;\n      case \"product\": go(type.part1); go(type.part2); return;\n    }\n  }\n  extractTypes(termAnn).forEach(type => go(type));\n  return freshTypeVariableId+1;\n}\n\nexport function makeFreshTypeVariable(termAnn: TermAnn): Type {\n  return {case: \"variable\", id: makeFreshTypeVariableId(termAnn)};\n}\n\nexport function normalizeTypeVariableIds(termAnn: TermAnn): TermAnn {\n  let substitutions: Map<TypeVariableId, TypeVariableId> = new Map();\n  let freshTypeVariableId = 0;\n\n  function goTypeVariableId(id: TypeVariableId): TypeVariableId {\n    let idNew = substitutions.get(id);\n    if (idNew !== undefined)\n      return idNew;\n    else {\n      substitutions.set(id, freshTypeVariableId);\n      idNew = freshTypeVariableId;\n      freshTypeVariableId++;\n      return idNew;\n    }\n  }\n  \n  function goType(type: Type): Type {\n    switch (type.case) {\n      case \"unit\": return {case: \"unit\"};\n      case \"variable\": return {case: \"variable\", id: goTypeVariableId(type.id)};\n      case \"arrow\": return {case: \"arrow\", domain: goType(type.domain), codomain: goType(type.codomain)};\n      case \"product\": return {case: \"product\", part1: goType(type.part1), part2: goType(type.part2)};\n    }\n  }\n\n  function goTermAnn(termAnn: TermAnn): TermAnn {\n    switch (termAnn.case) {\n      case \"unit\": return {case: \"unit\"};\n      case \"variable\": return {case: \"variable\", id: termAnn.id, type: goType(termAnn.type)};\n      case \"abstraction\": return {case: \"abstraction\", body: goTermAnn(termAnn.body), type: goType(termAnn.type)};\n      case \"application\": return {case: \"application\", applicant: goTermAnn(termAnn.applicant), argument: goTermAnn(termAnn.argument), type: goType(termAnn.type)};\n      case \"pair\": return {case: \"pair\", part1: goTermAnn(termAnn.part1), part2: goTermAnn(termAnn.part2), type: goType(termAnn.type)};\n      case \"proj1\": return {case: \"proj1\", argument: goTermAnn(termAnn.argument), type: goType(termAnn.type)};\n      case \"proj2\": return {case: \"proj2\", argument: goTermAnn(termAnn.argument), type: goType(termAnn.type)};\n      case \"hole\": return {case: \"hole\", id: termAnn.id, type: goType(termAnn.type)};\n    }\n  }\n\n  goType(extractType(termAnn));\n\n  return goTermAnn(termAnn);\n}\n","import { toArray } from \"./data/List\";\nimport { HoleId, holeIdToString, Term, termToString, Type, typeToString, VariableId, variableIdToString } from \"./language/Syntax\";\nimport { collectHoleContexts, Context, contextToString, infer, Inference, extractHoleType } from \"./language/Typing\";\n\nexport type State = {\n  term: Term;\n  type: Type;\n  focus: Focus | undefined;\n};\n\nexport type Focus = {\n  id: HoleId;\n  type: Type;\n  context: Context;\n  transitions: Transition[]; \n}\n\nexport type Transition\n  = { case: \"select\"; id: HoleId; }\n  | { case: \"put\"; put: Put }\n;\n\nexport type Put\n  = { case: \"unit\" }\n  | { case: \"variable\"; id: VariableId }\n  | { case: \"abstraction\" }\n  | { case: \"application\" }\n  | { case: \"pair\" }\n  | { case: \"proj1\" }\n  | { case: \"proj2\" }\n\nexport function stateToString(state: State): string {\n  return `term: ${termToString(state.term)}; type: ${typeToString(state.type)}; focus: ${focusToString(state.focus)}`;\n}\n\nexport function focusToString(focus: Focus | undefined): string {\n  if (focus !== undefined) {\n    return `id: ${focus.id}; type: ${typeToString(focus.type)}; context: ${contextToString(focus.context)}; transitions: ${focus.transitions.map(t => transitionToString(t)).join(\", \")}`;\n  } else \n    return \"unfocussed\"\n}\n\nexport function transitionToString(transition: Transition): string {\n  switch (transition.case) {\n    case \"select\": {\n      return `select hole id ${transition.id}`;\n    }\n    case \"put\": {\n      return `put ${putToString(transition.put)}`;\n    }\n  }\n}\n\nexport function putToString(put: Put): string {\n  switch (put.case) {\n    case \"unit\": return `unit`;\n    case \"variable\": return variableIdToString(put.id);\n    case \"abstraction\": return `λ ?`;\n    case \"application\": return `? ?`;\n    case \"pair\": return `(? , ?)`\n    case \"proj1\": return `π₁ ?`\n    case \"proj2\": return `π₂ ?`\n  }\n}\n\n// Update\n\nexport function update(state: State, transition: Transition): State {\n  switch (transition.case) {\n    case \"select\": {\n      // Infer hole type and context\n      let inference: Inference = infer(state.term);\n      let holeType: Type = extractHoleType(inference.termAnn, transition.id);\n      let holeContexts: Map<HoleId, Context> = collectHoleContexts(inference.termAnn);\n      {\n        let arr: string[] = [];\n        holeContexts.forEach((context, id) => arr.push(`${holeIdToString(id)}: ${contextToString(context)}`));\n      }\n      let holeContext: Context;\n      {\n        let res = holeContexts.get(transition.id);\n        if (res !== undefined)\n          holeContext = res;\n        else {\n          throw new Error(`hole id ${transition.id} not found among hole contexts`);\n        }\n      }\n\n      // Collect transitions\n      let transitions: Transition[] = [];\n      let putOptions: Put[] = [];\n      // Basic constructors\n      putOptions.push({case: \"unit\"});\n      putOptions.push({case: \"application\"});\n      putOptions.push({case: \"abstraction\"});\n      putOptions.push({case: \"pair\"});\n      putOptions.push({case: \"proj1\"});\n      putOptions.push({case: \"proj2\"});\n      // Variable constructors\n      toArray(holeContext).forEach((_, id) =>\n        putOptions.push({case: \"variable\", id})\n      );\n      putOptions.forEach(put => {\n        let fillTerm: Term;\n        switch (put.case) {\n          case \"unit\": fillTerm = {case: \"unit\"}; break;\n          case \"variable\": fillTerm = {case: \"variable\", id: put.id}; break;\n          case \"abstraction\": fillTerm = {case: \"abstraction\", body: {case: \"hole\", id: -1}}; break;\n          case \"application\": fillTerm = {case: \"application\", applicant: {case: \"hole\", id: -1}, argument: {case: \"hole\", id: -1}}; break;\n          case \"pair\": fillTerm = {case: \"pair\", part1: {case: \"hole\", id: -1}, part2: {case: \"hole\", id: -1}}; break;\n          case \"proj1\": fillTerm = {case: \"proj1\", argument: {case: \"hole\", id: -1}}; break;\n          case \"proj2\": fillTerm = {case: \"proj2\", argument: {case: \"hole\", id: -1}}; break;\n        }\n        let term: Term = fillHole(state.term, transition.id, fillTerm);\n        term = enumerateHoles(term);\n        try {\n          infer(term);\n          // if succeeds, then add\n          transitions.push({case: \"put\", put});\n        } catch (e) {\n          // pass\n          console.log(`failed inference: ${e}`);\n        }\n      });\n\n      // New state\n      return {\n        term: state.term,\n        type: inference.type,\n        focus: {\n          id: transition.id,\n          type: holeType,\n          context: holeContext,\n          transitions\n        }\n      };\n    }\n    case \"put\": {\n      // must have focus in order to \"put\"\n      let focus: Focus = state.focus as Focus;\n      let fillTerm: Term;\n      switch (transition.put.case) {\n        case \"unit\": fillTerm = {case: \"unit\"}; break;\n        case \"variable\": fillTerm = {case: \"variable\", id: transition.put.id}; break;\n        case \"abstraction\": fillTerm = {case: \"abstraction\", body: {case: \"hole\", id: -1}}; break;\n        case \"application\": fillTerm = {case: \"application\", applicant: {case: \"hole\", id: -1}, argument: {case: \"hole\", id: -1}}; break;\n        case \"pair\": fillTerm = {case: \"pair\", part1: {case: \"hole\", id: -1}, part2: {case: \"hole\", id: -1}}; break;\n        case \"proj1\": fillTerm = {case: \"proj1\", argument: {case: \"hole\", id: -1}}; break;\n        case \"proj2\": fillTerm = {case: \"proj2\", argument: {case: \"hole\", id: -1}}; break;\n      }\n      let term: Term = fillHole(state.term, focus.id, fillTerm);\n      term = enumerateHoles(term);\n      let inference: Inference = infer(term);\n      return {\n        term,\n        type: inference.type,\n        focus: undefined,\n      };\n    }\n  }\n\n  throw new Error(\"unimplemented\");\n}\n\nexport function fillHole(term: Term, id:HoleId, termFill: Term): Term {\n  switch (term.case) {\n    case \"unit\": return term;\n    case \"variable\": return term;\n    case \"abstraction\": return {case: \"abstraction\", body: fillHole(term.body, id, termFill)};\n    case \"application\": return {case: \"application\", applicant: fillHole(term.applicant, id, termFill), argument: fillHole(term.argument, id, termFill)};\n    case \"pair\": return {case: \"pair\", part1: fillHole(term.part1, id, termFill), part2: fillHole(term.part2, id, termFill)};\n    case \"proj1\": return {case: \"proj1\", argument: fillHole(term.argument, id, termFill)};\n    case \"proj2\": return {case: \"proj2\", argument: fillHole(term.argument, id, termFill)};\n    case \"hole\": {\n      if (term.id === id)\n        return termFill;\n      else \n        return term;\n    }\n  }\n}\n\nexport function enumerateHoles(term: Term): Term {\n  let freshHoleId = 0;\n  function freshHole(): Term {\n    let term: Term = {case: \"hole\", id: freshHoleId};\n    freshHoleId++;\n    return term;\n  }\n  function go(term: Term): Term {\n    switch (term.case) {\n      case \"unit\": return term;\n      case \"variable\": return term;\n      case \"abstraction\": return {case: \"abstraction\", body: go(term.body)};\n      case \"application\": return {case: \"application\", applicant: go(term.applicant), argument: go(term.argument)};\n      case \"pair\": return {case: \"pair\", part1: go(term.part1), part2: go(term.part2)};\n      case \"proj1\": return {case: \"proj1\", argument: go(term.argument)};\n      case \"proj2\": return {case: \"proj2\", argument: go(term.argument)};\n      case \"hole\": return freshHole();\n    }\n  }\n  term = go(term);\n  return term;\n}","import React, { MouseEventHandler } from 'react';\nimport './App.css';\nimport { toArray } from './data/List';\nimport { holeIdToString, Term, termToString, typeToString, variableIdToString } from './language/Syntax';\nimport { putToString, State, update } from './State';\n\nexport type AppProperties = {};\n\nexport default class App extends React.Component<AppProperties, State> {\n  state: State = {\n    term: {case: \"hole\", id: 0},\n    type: {case: \"variable\", id: 0},\n    focus: undefined\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        {this.viewConsole()}\n        {this.viewEnvironment()}\n        {this.viewPalette()}\n      </div>\n    );\n  }\n\n  viewEnvironment(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"environment\">\n          {this.viewContext()}\n          <hr/>\n          {this.viewGoal()}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewContext(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let variableViews: JSX.Element[] = [];\n      toArray(this.state.focus.context).forEach((type, id) =>\n        variableViews.push(\n          <div className=\"context-variable\">\n            {variableIdToString(id)}: {typeToString(type)}\n          </div>)\n      );\n      return (\n        <div className=\"context\">\n          {variableViews}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewGoal(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"goal\">\n          {typeToString(this.state.focus.type)}\n        </div>\n      );\n    } else\n    return (<div></div>);\n  }\n  \n  viewConsole(): JSX.Element {\n    let app = this;\n    function go(term: Term): JSX.Element {\n      switch (term.case) {\n        case \"unit\": return <span>{termToString(term)}</span>;\n        case \"variable\": return <span>{termToString(term)}</span>;\n        case \"abstraction\": {\n          let bodyView = go(term.body);\n          return (<span>(λ {bodyView})</span>);\n        }\n        case \"application\": {\n          let applicantView = go(term.applicant);\n          let argumentView = go(term.argument);\n          return (<span>({applicantView} {argumentView})</span>);\n        }\n        case \"pair\": {\n          let part1View = go(term.part1);\n          let part2View = go(term.part2);\n          return (<span>({part1View}, {part2View})</span>);\n        }\n        case \"proj1\": {\n          let argumentView = go(term.argument);\n          return (<span>(π₁ {argumentView})</span>)\n        }\n        case \"proj2\": {\n          let argumentView = go(term.argument);\n          return (<span>(π₂ {argumentView})</span>)\n        }\n        case \"hole\": {\n          let onClick: MouseEventHandler = e => app.setState(update(app.state, {case: \"select\", id: term.id}));\n          let className = app.state.focus !== undefined && app.state.focus.id === term.id ? \"hole focussed\" : \"hole\";\n          return (<span className={className} onClick={onClick}>{holeIdToString(term.id)}</span>);\n        }\n      }\n    }\n    return (\n      <div className=\"console\">\n        {go(this.state.term)} : {typeToString(this.state.type)}\n      </div>\n    )\n  }\n  \n  viewPalette(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let app = this;\n      let palleteItemViews: JSX.Element[] = [];\n\n      this.state.focus.transitions.forEach((transition) => {\n        switch (transition.case) {\n          case \"select\": break;\n          case \"put\": {\n            let onClick: MouseEventHandler = e => app.setState(update(app.state, transition));\n            palleteItemViews.push(\n              <div>\n                <div className=\"palette-item\" onClick={onClick}>\n                  {putToString(transition.put)}\n                </div>\n              </div>\n            );\n          }\n        }\n      })\n      return (\n        <div className=\"palette\">\n          {palleteItemViews}\n        </div>\n      );\n    } else {\n      return (<div></div>);\n    }\n    \n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}