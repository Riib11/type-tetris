{"version":3,"sources":["language/Syntax.ts","Typing.ts","State.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["typeToString","type","case","domain","codomain","id","alphabet","length","toUpperCase","Math","floor","termToString","term","variableIdToString","body","applicant","argument","infer","holeScopes","Map","holeTypes","variables","typeVariables","visibleVariableIds","inferVariable","get","undefined","Error","normalizeType","typeNext","freshTypeVariable","maxId","forEach","_","max","set","unify","type1","type2","normalizeTypesInTerm","inferTerm","push","pop","applicantType","map","holeContexts","variableIds","holeId","context","variableId","maxTypeVariableId","maxHoleId","maxVariableId","isSubtype","e","stateToString","state","focus","s","contextToString","transitions","t","transitionToString","transition","putToString","put","update","console","log","inference","holeContext","holeType","freshVariableId","freshTypeVariableId","holeIds","go","getHoleIds","freshHoleId","fillHole","termFill","App","className","this","viewConsole","viewGoal","viewContext","viewPalette","variableViews","app","bodyView","applicantView","argumentView","onClick","setState","palleteItemViews","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.47f9b0ce.chunk.js","sourcesContent":["// Program\n\nexport type Program = Term;\n\n// Type\n\nexport type Type\n  = { case: \"unit\"; }\n  | { case: \"variable\", id: TypeVariableId }\n  | { case: \"arrow\"; domain: Type; codomain: Type; }\n;\n\n// Term\n\nexport type Term\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; }\n  | { case: \"abstraction\"; id: VariableId; domain: Type; body: Term; }\n  | { case: \"application\"; applicant: Term; argument: Term; }\n  | { case: \"hole\"; id: HoleId }\n;\n\nexport type HoleId = number;\nexport type VariableId = number;\nexport type TypeVariableId = number;\n\n// ToString\n\nexport function typeToString(type: Type): string {\n  switch (type.case) {\n    case \"unit\": return \"Unit\";\n    case \"arrow\": return `(${typeToString(type.domain)} -> ${typeToString(type.codomain)})`;\n    case \"variable\": return typeVariableIdToString(type.id);\n  }\n}\n\nexport function termToString(term: Term): string {\n  switch (term.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return variableIdToString(term.id);\n    case \"abstraction\": return `(${variableIdToString(term.id)} : ${typeToString(term.domain)}) ⇒ ${termToString(term.body)}`;\n    case \"application\": return `(${termToString(term.applicant)} ${termToString(term.argument)})`;\n    case \"hole\": return `#${term.id}`;\n  }\n}\n\nexport function typeVariableIdToString(id: TypeVariableId): string {\n  if (id < alphabet.length)\n    return `${alphabet[id % alphabet.length].toUpperCase()}`;\n  else\n    return `${alphabet[id % alphabet.length].toUpperCase()}${Math.floor(id / alphabet.length)}`;\n}\n\nexport function variableIdToString(id: VariableId): string {\n  if (id < alphabet.length)\n    return `${alphabet[id % alphabet.length]}`;\n  else\n    return `${alphabet[id % alphabet.length]}${Math.floor(id / alphabet.length)}`;\n}\n\nexport function holeIdToString(id: HoleId): string {\n  return `#${id}`;\n}\n\nconst alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"];\n\n// // Fresh [Type]VariableId\n\n// function freshVariableId(term: Term): VariableId {\n//   let id: TypeVariableId = 0;\n//   function go(term: Term): void {\n//     switch (term.case) {\n//       case \"unit\": break;\n//       case \"variable\": id = Math.max(term.id, id); break;\n//       case \"abstraction\": id = Math.max(term.id, id); break;\n//       case \"application\": go(term.applicant); go(term.argument); break;\n//       case \"hole\": break;\n//     }\n//   }\n//   go(term);\n//   return id;\n// }\n\n// function freshTypeVariableId(term: Term): TypeVariableId {\n//   let id: TypeVariableId = 0;\n//   function go(term: Term): void {\n//     switch (term.case) {\n//       case \"unit\": break;\n//       case \"variable\": break;\n//       case \"abstraction\": id = Math.max(term., id); break;\n//       case \"application\": go(term.applicant); go(term.argument); break;\n//       case \"hole\": break;\n//     }\n//   }\n// }","import { HoleId, Term, Type, VariableId, TypeVariableId, typeToString, termToString, variableIdToString } from \"./language/Syntax\";\n\nexport type Context = Map<VariableId, Type>;\n\nexport function contextToString(context: Context): string {\n  let s = \"\";\n  context.forEach((type, id) => s += `(${variableIdToString(id)}: ${typeToString(type)})`);\n  return s;\n}\n\n// Inference\n\nexport type Inference = {\n  type: Type;\n\n  holeTypes: Map<HoleId, Type>;\n  holeContexts: Map<HoleId, Context>;\n\n  maxVariableId: VariableId;\n  maxTypeVariableId: TypeVariableId;\n  maxHoleId: HoleId;\n}\n\nexport function infer(term: Term): Inference {\n  let holeScopes: Map<HoleId, VariableId[]> = new Map();\n  let holeTypes: Map<HoleId, Type> = new Map();\n  let variables: Map<VariableId, Type> = new Map();\n  let typeVariables: Map<TypeVariableId, Type | undefined> = new Map(); // `unidentified` indicates free type variable\n  let visibleVariableIds: VariableId[] = [];\n\n  // Term Variables\n\n  function inferVariable(id: VariableId): Type {\n    let type = variables.get(id);\n    if (type !== undefined) \n      return type;\n    else\n      throw new Error(`undefined variable: ${id}`);\n  }\n\n  // Type Variables\n\n  function normalizeType(type: Type): Type {\n    switch (type.case) {\n      case \"unit\": {\n        return type;\n      }\n      case \"variable\": {\n        if (type.id !== undefined) {\n          let typeNext = typeVariables.get(type.id);\n          if (typeNext !== undefined)\n            return normalizeType(typeNext); // is dependent\n          else\n            return type; // is free\n        } else\n          throw new Error(`unidentified variable`);\n      }\n      case \"arrow\": {\n        return {case: \"arrow\", domain: normalizeType(type.domain), codomain: normalizeType(type.codomain)};\n      }\n    }\n  }\n\n  function freshTypeVariable(): Type {\n    let maxId = 0;\n    typeVariables.forEach((_, id) => maxId = Math.max(maxId, id))\n    let id = maxId + 1;\n    typeVariables.set(id, undefined);\n    return {case: \"variable\", id: id};\n  }\n\n  // Term Inference\n\n  function inferTerm(term: Term): Type {\n    switch (term.case) {\n      case \"unit\": {\n        return {case: \"unit\"};\n      }\n      case \"variable\": {\n        return inferVariable(term.id);\n      }\n      case \"abstraction\": {\n        variables.set(term.id, term.domain);\n        visibleVariableIds.push(term.id);\n        let codomain = inferTerm(term.body);\n        visibleVariableIds.pop();\n        return {case: \"arrow\", domain: term.domain, codomain};\n      }\n      case \"application\": {\n        let applicantType = inferTerm(term.applicant);\n        let domain: Type = freshTypeVariable();\n        let codomain: Type = freshTypeVariable();\n        unify(applicantType, {case: \"arrow\", domain, codomain});\n        let argumentType = inferTerm(term.argument);\n        unify(argumentType, domain);\n        return codomain;\n      }\n      case \"hole\": {\n        let type = freshTypeVariable();\n        holeTypes.set(term.id, type);\n        holeScopes.set(term.id, visibleVariableIds.map(id => id));\n        return type;\n      }\n    }\n  }\n\n  // Type Unification\n\n  function unify(type1: Type, type2: Type): Type {\n    switch (type1.case) {\n      case \"unit\": {\n        switch (type2.case) {\n          case \"unit\": {\n            return {case: \"unit\"};\n          }\n          case \"variable\": {\n            typeVariables.set(type2.id, type1);\n            return type1;\n          }\n          case \"arrow\": {\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n          }\n        }\n        break;\n      }\n      case \"variable\": {\n        switch (type2.case) {\n          case \"unit\": {\n            typeVariables.set(type1.id, type2);\n            return type2;\n          }\n          case \"variable\": {\n            typeVariables.set(type1.id, type2);\n            return type2;\n          }\n          case \"arrow\": {\n            typeVariables.set(type1.id, type2);\n            return type2;\n          }\n        }\n        break;\n      }\n      case \"arrow\": {\n        switch (type2.case) {\n          case \"unit\": {\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n          }\n          case \"variable\": {\n            typeVariables.set(type2.id, type1);\n            return type1;\n          } \n          case \"arrow\": {\n            unify(type1.domain, type2.domain);\n            unify(type1.codomain, type2.codomain);\n            return type1;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  // Normalizing Types in Term\n\n  function normalizeTypesInTerm(term: Term): void {\n    switch (term.case) {\n      case \"unit\": break;\n      case \"variable\": break;\n      case \"abstraction\": {\n        term.domain = normalizeType(term.domain);\n        break;\n      }\n      case \"application\": {\n        normalizeTypesInTerm(term.applicant);\n        normalizeTypesInTerm(term.argument);\n        break;\n      }\n      case \"hole\": break;\n    }\n  }\n  normalizeTypesInTerm(term);\n\n  let type = normalizeType(inferTerm(term));\n  let holeContexts: Map<HoleId, Context> = new Map();\n  holeScopes.forEach((variableIds, holeId) => {\n    let context: Context = new Map();\n    variableIds.forEach(variableId => context.set(variableId, normalizeType(inferVariable(variableId))));\n    holeContexts.set(holeId, context);\n  })\n  holeTypes.forEach(type => normalizeType(type));\n\n  let maxTypeVariableId = 0;\n  typeVariables.forEach((_, id) => maxTypeVariableId = Math.max(id, maxTypeVariableId));\n\n  let maxVariableId = 0;\n  variables.forEach((_, id) => maxTypeVariableId = Math.max(id, maxVariableId));\n\n  let maxHoleId = 0;\n  holeTypes.forEach((_, id) => maxHoleId = Math.max(id, maxHoleId));\n\n  return {\n    type,\n\n    holeTypes,\n    holeContexts,\n\n    maxVariableId,\n    maxTypeVariableId,\n    maxHoleId\n  };\n}\n\nexport function isSubtype(term: Term, type1: Type, type2: Type): boolean {\n  let variables: Map<VariableId, Type> = new Map();\n  let typeVariables: Map<TypeVariableId, Type | undefined> = new Map(); // `unidentified` indicates free type variable\n\n  // Term Variables\n\n  function inferVariable(id: VariableId): Type {\n    let type = variables.get(id);\n    if (type !== undefined) \n      return type;\n    else\n      throw new Error(`undefined variable: ${id}`);\n  }\n\n  // Type Variables\n\n  function normalizeType(type: Type): Type {\n    switch (type.case) {\n      case \"unit\": {\n        return type;\n      }\n      case \"variable\": {\n        if (type.id !== undefined) {\n          let typeNext = typeVariables.get(type.id);\n          if (typeNext !== undefined)\n            return normalizeType(typeNext); // is dependent\n          else\n            return type; // is free\n        } else\n          throw new Error(`unidentified variable`);\n      }\n      case \"arrow\": {\n        return {case: \"arrow\", domain: normalizeType(type.domain), codomain: normalizeType(type.codomain)};\n      }\n    }\n  }\n\n  function freshTypeVariable(): Type {\n    let maxId = 0;\n    typeVariables.forEach((_, id) => maxId = Math.max(maxId, id))\n    let id = maxId + 1;\n    typeVariables.set(id, undefined);\n    return {case: \"variable\", id: id};\n  }\n\n  // Term Inference\n\n  function inferTerm(term: Term): Type {\n    switch (term.case) {\n      case \"unit\": {\n        return {case: \"unit\"};\n      }\n      case \"variable\": {\n        return inferVariable(term.id);\n      }\n      case \"abstraction\": {\n        let codomain = inferTerm(term.body);\n        return {case: \"arrow\", domain: term.domain, codomain};\n      }\n      case \"application\": {\n        let applicantType = inferTerm(term.applicant);\n        let domain: Type = freshTypeVariable();\n        let codomain: Type = freshTypeVariable();\n        unify(applicantType, {case: \"arrow\", domain, codomain});\n        let argumentType = inferTerm(term.argument);\n        unify(argumentType, domain);\n        return codomain;\n      }\n      case \"hole\": {\n        let type = freshTypeVariable();\n        return type;\n      }\n    }\n  }\n\n  inferTerm(term);\n\n  // Type Unification\n\n  function unify(type1: Type, type2: Type): Type {\n    switch (type1.case) {\n      case \"unit\": {\n        switch (type2.case) {\n          case \"unit\": {\n            return {case: \"unit\"};\n          }\n          case \"variable\": {\n            typeVariables.set(type2.id, type1);\n            return type1;\n          }\n          case \"arrow\": {\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n          }\n        }\n        break;\n      }\n      case \"variable\": {\n        switch (type2.case) {\n          case \"unit\": {\n            typeVariables.set(type1.id, type2);\n            return type2;\n          }\n          case \"variable\": {\n            typeVariables.set(type1.id, type2);\n            return type2;\n          }\n          case \"arrow\": {\n            typeVariables.set(type1.id, type2);\n            return type2;\n          }\n        }\n        break;\n      }\n      case \"arrow\": {\n        switch (type2.case) {\n          case \"unit\": {\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`);\n          }\n          case \"variable\": {\n            typeVariables.set(type2.id, type1);\n            return type1;\n          } \n          case \"arrow\": {\n            unify(type1.domain, type2.domain);\n            unify(type1.codomain, type2.codomain);\n            return type1;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  type1 = normalizeType(type1);\n  type2 = normalizeType(type2);\n  try {\n    unify(type1, type2);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","import { Term, Type, HoleId, VariableId, TypeVariableId, termToString, typeToString, variableIdToString } from \"./language/Syntax\";\nimport { infer, Inference, Context, isSubtype, contextToString } from \"./Typing\";\n\nexport type State = {\n  term: Term;\n  type: Type;\n  focus: Focus | undefined;\n};\n\nexport type Focus = {\n  id: HoleId;\n  type: Type;\n  context: Context;\n  transitions: Transition[]; \n}\n\nexport type Transition\n  = { case: \"select\"; id: HoleId; }\n  | { case: \"put\"; put: Put }\n;\n\nexport type Put\n  = { case: \"unit\" }\n  | { case: \"variable\"; id: VariableId }\n  | { case: \"abstraction\"; domain: Type; id: VariableId }\n  | { case: \"application\" }\n\nexport function stateToString(state: State): string {\n  return `term: ${termToString(state.term)}; type: ${typeToString(state.type)}; focus: ${focusToString(state.focus)}`;\n}\n\nexport function focusToString(focus: Focus | undefined): string {\n  if (focus !== undefined) {\n    return `id: ${focus.id}; type: ${typeToString(focus.type)}; context: ${contextToString(focus.context)}; transitions: ${focus.transitions.map(t => transitionToString(t))}`;\n  } else \n    return \"unfocussed\"\n}\n\nexport function transitionToString(transition: Transition): string {\n  switch (transition.case) {\n    case \"select\": {\n      return `select hole id ${transition.id}`;\n    }\n    case \"put\": {\n      return `put ${putToString(transition.put)}`;\n    }\n  }\n}\n\nexport function putToString(put: Put): string {\n  switch (put.case) {\n    case \"unit\": return `unit`;\n    case \"variable\": return variableIdToString(put.id);\n    case \"abstraction\": return `(${variableIdToString(put.id)}: ${typeToString(put.domain)}) ⇒ ?`;\n    case \"application\": return `? ?`;\n  }\n}\n\n// Update\n\nexport function update(state: State, transition: Transition): State {\n  console.log(`update`);\n  console.log(`input state: ${stateToString(state)}`);\n  console.log(`transition: ${transitionToString(transition)}`);\n\n  switch (transition.case) {\n    case \"select\": {\n      let inference: Inference = infer(state.term);\n      let holeContext = inference.holeContexts.get(transition.id) as Context;\n      let holeType = inference.holeTypes.get(transition.id) as Type;\n\n      // calculate available transitions from state focussed on this hole\n      let transitions: Transition[] = [];\n\n      // produce fresh type/term variable ids\n      let freshVariableId: VariableId = inference.maxVariableId + 1;\n      let freshTypeVariableId: TypeVariableId = inference.maxTypeVariableId + 1;\n\n      // basic constructors\n      switch (holeType.case) {\n        case \"unit\": {\n          transitions.push({ case: \"put\", put: {case: \"unit\"} });\n          transitions.push({ case: \"put\", put: {case: \"application\"} });\n          break;\n        }\n        case \"arrow\": {\n          transitions.push({ case: \"put\", put: {case: \"abstraction\", domain: holeType.domain, id: freshVariableId}});\n          transitions.push({ case: \"put\", put: {case: \"application\"}});\n          break;\n        }\n        case \"variable\": {\n          transitions.push({ case: \"put\", put: {case: \"unit\"}});\n          transitions.push({ case: \"put\", put: {case: \"abstraction\", domain: {case: \"variable\", id: freshTypeVariableId}, id: freshVariableId}});\n          transitions.push({ case: \"put\", put: {case: \"application\" } });\n          break;\n        }\n      }\n\n      // variable constructors\n      holeContext.forEach((type, id) => {\n        if (isSubtype(state.term, type, holeType)) {\n          transitions.push({ case: \"put\", put: { case: \"variable\", id } });\n        }\n      });\n\n      // hole selections\n      getHoleIds(state.term).forEach(id => {\n        transitions.push({ case: \"select\", id });\n      });\n\n      // new state\n      state.focus = {\n        id: transition.id,\n        type: holeType,\n        context: holeContext,\n        transitions\n      };\n      break;\n    }\n    \n    case \"put\": {\n      // must have focus in order to \"put\"\n      let focus: Focus = state.focus as Focus;\n\n      \n      // inference\n      let inference = infer(state.term);\n      let freshHoleId = inference.maxHoleId + 1;\n      \n      // fill hole\n      let term;\n      switch (transition.put.case) {\n        case \"unit\": {\n          term = fillHole(state.term, focus.id, {case: \"unit\"});\n          break;\n        }\n        case \"variable\": {\n          term = fillHole(state.term, focus.id, {case: \"variable\", id: transition.put.id});\n          break;\n        }\n        case \"abstraction\": {\n          let body: Term = {case: \"hole\", id: freshHoleId};\n          term = fillHole(state.term, focus.id, {case: \"abstraction\", id: transition.put.id, domain: transition.put.domain, body});\n          break;\n        }\n        case \"application\": {\n          let applicant: Term = {case: \"hole\", id: freshHoleId};\n          let argument:  Term = {case: \"hole\", id: freshHoleId+1};\n          term = fillHole(state.term, focus.id, {case: \"application\", applicant, argument});\n          break;\n        }\n      }\n      if (term !== undefined) {\n        let inference = infer(term);\n        // new state\n        state.term = term;\n        state.type = inference.type;\n        state.focus = undefined;\n      } else {\n        throw new Error(\"impossible\");\n      }\n    }\n  }\n  console.log(`output state: ${stateToString(state)}`);\n  return state;\n}\n\n// Holes\n\nfunction getHoleIds(term: Term): HoleId[] {\n  let holeIds: HoleId[] = [];\n  function go(term: Term): void {\n    switch (term.case) {\n      case \"unit\": break;\n      case \"variable\": break;\n      case \"abstraction\": go(term.body); break;\n      case \"application\": go(term.applicant); go(term.argument); break;\n      case \"hole\": holeIds.push(term.id); break;\n    }    \n  }\n  go(term);\n  return holeIds;\n}\n\nfunction fillHole(term: Term, id:  HoleId, termFill: Term): Term {\n  function go(term: Term): Term {\n    switch (term.case) {\n      case \"unit\": return term;\n      case \"variable\": return term;\n      case \"abstraction\": return { case: \"abstraction\", id: term.id, domain: term.domain, body: go(term.body) };\n      case \"application\": return { case: \"application\", applicant: go(term.applicant), argument: go(term.argument) };\n      case \"hole\": return termFill;\n    }\n  }\n  return go(term);\n}\n\n","import React, { MouseEventHandler } from 'react';\nimport './App.css';\nimport { holeIdToString, Term, termToString, typeToString, variableIdToString } from './language/Syntax';\nimport { Put, putToString, State, Transition, transitionToString, update } from './State';\n\nexport type AppProperties = {};\n\nexport default class App extends React.Component<AppProperties, State> {\n  state: State = {\n    term: {case: \"hole\", id: 0},\n    type: {case: \"variable\", id: 0},\n    focus: undefined\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        {this.viewConsole()}\n        <hr />\n        {this.viewGoal()}\n        <hr />\n        {this.viewContext()}\n        <hr />\n        {this.viewPalette()}\n      </div>\n    );\n  }\n  \n  viewContext(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let variableViews: JSX.Element[] = [];\n      this.state.focus.context.forEach((type, id) =>\n        variableViews.push(\n          <div className=\"context-variable\">\n            {variableIdToString(id)}: {typeToString(type)}\n          </div>)\n      );\n      return (\n        <div className=\"context\">\n          Context: {variableViews}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewGoal(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"goal\">\n          Goal: {typeToString(this.state.type)}\n        </div>\n      );\n    } else\n    return (<div></div>);\n  }\n  \n  viewConsole(): JSX.Element {\n    let app = this;\n    function go(term: Term): JSX.Element {\n      switch (term.case) {\n        case \"unit\": return <span>{termToString(term)}</span>;\n        case \"variable\": return <span>{termToString(term)}</span>;\n        case \"abstraction\": {\n          let bodyView = go(term.body);\n          return (<span>(({variableIdToString(term.id)}: {typeToString(term.domain)}) ⇒ {bodyView})</span>);\n        }\n        case \"application\": {\n          let applicantView = go(term.applicant);\n          let argumentView = go(term.argument);\n          return (<span>({applicantView} {argumentView})</span>);\n        }\n        case \"hole\": {\n          let onClick: MouseEventHandler = e => app.setState(update(app.state, {case: \"select\", id: term.id}));\n          let className = app.state.focus !== undefined && app.state.focus.id === term.id ? \"hole focussed\" : \"hole\";\n          return (<span className={className} onClick={onClick}>#{term.id}</span>);\n        }\n      }\n    }\n    return (\n      <div className=\"console\">\n        {go(this.state.term)} : {typeToString(this.state.type)}\n      </div>\n    )\n  }\n  \n  viewPalette(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let app = this;\n      let palleteItemViews: JSX.Element[] = [];\n\n      this.state.focus.transitions.forEach((transition) => {\n        switch (transition.case) {\n          case \"select\": break;\n          case \"put\": {\n            let onClick: MouseEventHandler = e => app.setState(update(app.state, transition));\n            palleteItemViews.push(\n              <div className=\"palette-item\" onClick={onClick}>\n                {putToString(transition.put)}\n              </div>\n            );\n          }\n        }\n      })\n      return (\n        <div className=\"palette\">\n          {palleteItemViews}\n        </div>\n      );\n    } else {\n      return (<div></div>);\n    }\n    \n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}