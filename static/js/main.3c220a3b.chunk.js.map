{"version":3,"sources":["data/List.ts","language/Syntax.ts","data/LinkedMap.ts","Typing.ts","State.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["cloneList","l","case","head","tail","toArray","arr","go","push","reverse","typeToString","type","typeVariableIdToString","id","domain","codomain","alphabet","length","Math","floor","toString","termToString","term","variableIdToString","body","applicant","argument","holeIdToString","termAnnToString","termAnn","concatMaps","m1","m2","key","value","singleMap","contextToString","context","map","join","annotate","freshTypeVariableId","freshTypeVariable","inferVariable","extractType","Error","infer","console","log","constraints","f","a","collectConstraints","substitution","forEach","item","sub","unify","applySubstitution","unifyConstraints","applySubstitutionTermAnn","holeContexts","collectHoleContexts","Map","set","substitute","typeNew","type1","type2","occursIn","stateToString","state","undefined","focus","transitions","t","transitionToString","transition","putToString","put","update","holeContext","inference","holeType","holeId","extractHoleType","res","get","putOptions","fillTerm","fillHole","enumerateHoles","e","termFill","freshHoleId","freshHole","App","className","this","viewConsole","viewGoal","viewContext","viewPalette","variableViews","app","bodyView","applicantView","argumentView","onClick","setState","palleteItemViews","React","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3c220a3b.chunk.js","sourcesContent":["export type List<A>\n  = { case: \"nil\" }\n  | { case: \"cons\"; head: A, tail: List<A> }\n;\n\nexport function single<A>(a: A): List<A> {\n  return {case: \"cons\", head: a, tail: {case: \"nil\"}};\n}\n\nexport function cloneList<A>(l: List<A>): List<A> {\n  switch (l.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", head: l.head, tail: cloneList(l.tail)};\n  }\n}\n\nexport function mapList<A, B>(f:(a: A) => B, l: List<A>): List<B> {\n  switch (l.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": return {case: \"cons\", head: f(l.head), tail: mapList(f, l.tail)}\n  }\n}\n\nexport function toArray<A>(l: List<A>): A[] {\n  let arr: A[] = [];\n  function go(l: List<A>): void {\n    switch (l.case) {\n      case \"nil\": return;\n      case \"cons\": arr.push(l.head); go(l.tail); return;\n    }\n  }\n  go(l);\n  return arr.reverse();\n}","// Program\n\nexport type Program = Term;\n\n// Type\n\nexport type Type\n  = { case: \"unit\"; }\n  | { case: \"variable\", id: TypeVariableId }\n  | { case: \"arrow\"; domain: Type; codomain: Type; }\n;\n\nexport function typeToString(type: Type): string {\n  switch (type.case) {\n    case \"unit\": return \"Unit\";\n    case \"variable\": return typeVariableIdToString(type.id);\n    case \"arrow\": return `(${typeToString(type.domain)} -> ${typeToString(type.codomain)})`;\n  }\n}\n\nexport function typeVariableIdToString(id: TypeVariableId): string {\n  let letter = alphabet[id % alphabet.length];\n  let suffix = id > alphabet.length ? Math.floor(id / alphabet.length).toString() : \"\";\n  return letter + suffix;\n}\n\n// Term\n\nexport type Term\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; }\n  | { case: \"abstraction\"; body: Term; }\n  | { case: \"application\"; applicant: Term; argument: Term; }\n  | { case: \"hole\"; id: HoleId }\n;\n\nexport function termToString(term: Term): string {\n  switch (term.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return variableIdToString(term.id);\n    case \"abstraction\": return `(λ ${termToString(term.body)})`;\n    case \"application\": return `(${termToString(term.applicant)} ${termToString(term.argument)})`;\n    case \"hole\": return holeIdToString(term.id);\n  }\n}\n\nexport function variableIdToString(id: VariableId): string {\n  return id.toString();\n  // let letter = alphabet[id % alphabet.length];\n  // let suffix = id > alphabet.length ? Math.floor(id / alphabet.length).toString() : \"\";\n  // return letter + suffix;\n}\n\nexport function holeIdToString(id: HoleId): string {\n  return `?${id}`;\n}\n\nexport type TermAnn\n  = { case: \"unit\"; }\n  | { case: \"variable\"; id: VariableId; type: Type; }\n  | { case: \"abstraction\"; body: TermAnn; type: Type; }\n  | { case: \"application\"; applicant: TermAnn; argument: TermAnn; type: Type; }\n  | { case: \"hole\"; id: HoleId; type: Type; }\n;\n\nexport function termAnnToString(termAnn: TermAnn): string {\n  switch (termAnn.case) {\n    case \"unit\": return \"unit\";\n    case \"variable\": return `(${variableIdToString(termAnn.id)}: ${typeToString(termAnn.type)})`;\n    case \"abstraction\": return `(λ ${termAnnToString(termAnn.body)}): ${typeToString(termAnn.type)}`;\n    case \"application\": return `(${termAnnToString(termAnn.applicant)} ${termAnnToString(termAnn.argument)}): ${typeToString(termAnn.type)}`;\n    case \"hole\": return `(${holeIdToString(termAnn.id)}: ${typeToString(termAnn.type)})`;\n  }\n}\n\nexport type HoleId = number;\nexport type VariableId = number;\nexport type TypeVariableId = number;\n\nconst alphabet = [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"];","export type LinkedMap<K, V>\n  = { case: \"nil\"; }\n  | { case: \"cons\"; key: K; value: V; tail: LinkedMap<K, V> }\n\nexport function lookup<K, V>(m: LinkedMap<K, V>, k: K): V | undefined {\n  switch (m.case) {\n    case \"nil\":\n      return undefined;\n    case \"cons\":\n      if (m.key === k)\n        return m.value;\n      else\n        return lookup(m.tail, k);\n  }\n}\n\nexport function keys<K, V>(m: LinkedMap<K, V>): K[] {\n  let ks: K[] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        ks.push(m.key);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return ks;\n}\n\nexport function items<K, V>(m: LinkedMap<K, V>): [K, V][] {\n  let items: [K, V][] = [];\n  function go(m: LinkedMap<K, V>): void {\n    switch (m.case) {\n      case \"nil\":\n        return;\n      case \"cons\":\n        items.push([m.key, m.value]);\n        go(m.tail);\n    }\n  }\n  go(m);\n  return items;\n}\n\nexport function filterMap<K, V>(m: LinkedMap<K, V>, f: (v: V) => boolean): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\":\n      return { case: \"nil\" };\n    case \"cons\": {\n      if (f(m.value))\n        return { \n          case: \"cons\",\n          key: m.key,\n          value: m.value,\n          tail: filterMap(m.tail, f)\n        };\n      else \n        return filterMap(m.tail, f);\n    }\n  }\n}\n\nexport function concatMaps<K, V>(m1: LinkedMap<K, V>, m2: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m1.case) {\n    case \"nil\": return m2;\n    case \"cons\": {\n      return concatMaps(m1.tail, {case: \"cons\", key: m1.key, value: m1.value, tail: m2});\n    }\n  }\n}\n\nexport function singleMap<K, V>(key: K, value: V): LinkedMap<K, V> {\n  return {case: \"cons\", key, value, tail: {case: \"nil\"}};\n}\n\nexport function cloneMap<K, V>(m: LinkedMap<K, V>): LinkedMap<K, V> {\n  switch (m.case) {\n    case \"nil\": return {case: \"nil\"};\n    case \"cons\": {\n      return {case: \"cons\", key: m.key, value: m.value, tail: cloneMap(m.tail)};\n    }\n  }\n}","import { concatMaps, LinkedMap, singleMap } from \"./data/LinkedMap\";\nimport { cloneList, List, toArray } from \"./data/List\";\nimport { HoleId, Term, TermAnn, termAnnToString, Type, typeToString, TypeVariableId, typeVariableIdToString, VariableId } from \"./language/Syntax\";\n\nexport type Context = List<Type>;\nexport type Constraints = [Type, Type][];\nexport type Substitution = LinkedMap<TypeVariableId, Type>;\n\nexport function contextToString(context: Context): string {\n  let res: string = toArray(context).map((type, id) => `${id}: ${typeToString(type)}`).join(\", \");\n  return res;\n}\n\n// TODO: During inferece, get the term variable context at hole (which needs to\n//       have unification substitutions applied to it).\nexport function annotate(term: Term): TermAnn {\n  let freshTypeVariableId = 0;\n  function freshTypeVariable(): Type {\n    let type: Type = {case: \"variable\", id: freshTypeVariableId};\n    freshTypeVariableId++;\n    return type;\n  }\n\n  function go(context: Context, term: Term): TermAnn {\n    switch (term.case) {\n      case \"unit\": {\n        return {case: \"unit\"};\n      }\n      case \"variable\": {\n        let type = inferVariable(context, term.id);\n        return {case: \"variable\", id: term.id, type};\n      }\n      case \"abstraction\": {\n        let domain: Type = freshTypeVariable();\n        let body: TermAnn = go({case: \"cons\", head: domain, tail: context}, term.body);\n        return {case: \"abstraction\", body, type: {case: \"arrow\", domain, codomain: extractType(body)}};\n      }\n      case \"application\": {\n        return {case: \"application\", applicant: go(context, term.applicant), argument: go(context, term.argument), type: freshTypeVariable()};\n      }\n      case \"hole\": {\n        let type = freshTypeVariable();\n        return {case: \"hole\", id: term.id, type};\n      }\n    };\n    throw new Error(\"impossible\")\n  }\n  return go({case: \"nil\"}, term);\n}\n\nexport function collectConstraints(term: TermAnn): Constraints {\n  let constraints: Constraints = [];\n  function go(term: TermAnn): void {\n    switch (term.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": go(term.body); return;\n      case \"application\": {\n        let [f, a] = [extractType(term.applicant), extractType(term.argument)];\n        constraints.push([f, {case: \"arrow\", domain: a, codomain: term.type}]);\n        go(term.applicant);\n        go(term.argument);\n        return;\n      }\n      case \"hole\": return;\n    }\n  }\n  go(term);\n  return constraints;\n}\n\nexport function inferVariable(context: Context, id: VariableId): Type {\n  switch (context.case) {\n    case \"nil\": throw new Error(\"variable id out-of-bounds\");\n    case \"cons\": {\n      if (id === 0)\n        return context.head;\n      else\n        return inferVariable(context.tail, id-1);\n    }\n  }\n}\n\nexport type Inference = {\n  termAnn: TermAnn,\n  type: Type,\n  substitution: Substitution,\n  holeContexts: Map<HoleId, Context>;\n}\n\nexport function infer(term: Term): Inference {\n  let termAnn: TermAnn = annotate(term);\n  console.log(`termAnn: ${termAnnToString(termAnn)}`);\n  let constraints: Constraints = collectConstraints(termAnn);\n  console.log(`constraints: ...`)\n  let substitution: Substitution = unifyConstraints(constraints);\n  console.log(`substitution: ...`)\n  termAnn = applySubstitutionTermAnn(substitution, termAnn);\n  console.log(`substituted termAnn: ${termAnnToString(termAnn)}`);\n  let type = extractType(termAnn);\n  console.log(`extracted type: ${typeToString(type)}`);\n  let holeContexts: Map<HoleId, Context> = collectHoleContexts(termAnn);\n  console.log(`holeContexts: ...`);\n  return {\n    termAnn,\n    type,\n    substitution,\n    holeContexts\n  };\n}\n\nexport function applySubstitutionTermAnn(substitution: Substitution, termAnn: TermAnn): TermAnn {\n  switch (termAnn.case) {\n    case \"unit\": return termAnn;\n    case \"variable\": return {case: \"variable\", id: termAnn.id, type: applySubstitution(substitution, termAnn.type)};\n    case \"abstraction\": return {case: \"abstraction\", body: applySubstitutionTermAnn(substitution, termAnn.body), type: applySubstitution(substitution, termAnn.type)};\n    case \"application\": return {case: \"application\", applicant: applySubstitutionTermAnn(substitution, termAnn.applicant), argument: applySubstitutionTermAnn(substitution, termAnn.argument), type: applySubstitution(substitution, termAnn.type)};\n    case \"hole\": return {case: \"hole\", id: termAnn.id, type: applySubstitution(substitution, termAnn.type)};\n  }\n}\n\nexport function collectHoleContexts(termAnn: TermAnn): Map<HoleId, Context> {\n  let holeContexts: Map<HoleId, Context> = new Map();\n  function go(context: Context, termAnn: TermAnn): void {\n    console.log(`context: ${contextToString(context)}`);\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": {\n        switch (termAnn.type.case) {\n          case \"arrow\": {\n            console.log(`TEST: ${contextToString({case: \"cons\", head: termAnn.type.domain, tail: context})}`);\n            go({case: \"cons\", head: termAnn.type.domain, tail: context}, termAnn.body);\n            return;\n          }\n          default: {\n            throw new Error(\"impossible\");\n          }\n        }\n      }\n      case \"application\": {\n        go(context, termAnn.applicant);\n        go(context, termAnn.argument);\n        break;\n      }\n      case \"hole\": {\n        holeContexts.set(termAnn.id, cloneList(context));\n        break;\n      }\n    }\n  }\n  go({case: \"nil\"}, termAnn);\n  return holeContexts;\n}\n\nexport function substitute(id: TypeVariableId, typeNew: Type, type: Type): Type {\n  switch (type.case) {\n    case \"unit\": return type;\n    case \"variable\": {\n      if (type.id === id)\n        return typeNew;\n      else\n        return type;\n    }\n    case \"arrow\": {\n      return {\n        case: \"arrow\",\n        domain: substitute(id, typeNew, type.domain),\n        codomain: substitute(id, typeNew, type.codomain)\n      };\n    }\n  }\n}\n\n// TODO: this is a fold-right, perhaps it should be a fold-left? Im not sure\n//       which things I got backwards\nexport function applySubstitution(substitution: Substitution, type: Type): Type {\n  switch (substitution.case) {\n    case \"nil\": return type;\n    case \"cons\": {\n      return substitute(\n        substitution.key, \n        substitution.value, \n        applySubstitution(substitution.tail, type));\n    }\n  }\n}\n\nexport function unifyConstraints(constraints: Constraints): Substitution {\n  let substitution: Substitution = {case: \"nil\"};\n  // TODO: this might be applying or concating backwards?\n  constraints.forEach(item => {\n    let sub = unify(applySubstitution(substitution, item[0]), applySubstitution(substitution, item[1]));\n    substitution = concatMaps(substitution, sub);\n  });\n  return substitution;\n}\n\nexport function unify(type1: Type, type2: Type): Substitution {\n  switch (type1.case) {\n    case \"unit\": {\n      switch (type2.case) {\n        case \"unit\": return {case: \"nil\"};\n        case \"variable\": return singleMap(type2.id, type1);\n        case \"arrow\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n      }\n      break;\n    }\n    case \"variable\": {\n      switch (type2.case) {\n        case \"unit\": return {case: \"nil\"};\n        case \"variable\": {\n          if (type1.id === type2.id)\n            return {case: \"nil\"};\n          else\n            return singleMap(type1.id, type2);\n        }\n        case \"arrow\": {\n          if (occursIn(type1.id, type2))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type1.id)}`);\n          else\n            return singleMap(type1.id, type2);\n        }\n      }\n      break;\n    }\n    case \"arrow\": {\n      switch (type2.case) {\n        case \"unit\": throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)}`)\n        case \"variable\": {\n          if (occursIn(type2.id, type2))\n            throw new Error(`cannot unify ${typeToString(type1)} with ${typeToString(type2)} because of circularity on ${typeVariableIdToString(type2.id)}`);\n          else\n            return singleMap(type2.id, type1);\n        }\n        case \"arrow\": {\n          return concatMaps(\n            unify(type1.domain, type2.domain),\n            unify(type1.codomain, type2.codomain));\n        }\n      }\n      break;\n    }\n  }\n  throw new Error(\"impossible\");\n}\n\n// Checks if `id` occurs in `type`\nexport function occursIn(id: TypeVariableId, type: Type): boolean {\n  switch (type.case) {\n    case \"unit\": return false;\n    case \"variable\": return id === type.id;\n    case \"arrow\": return occursIn(id, type.domain) || occursIn(id, type.codomain);\n  }\n}\n\nexport function extractType(term: TermAnn): Type {\n  switch (term.case) {\n    case \"unit\": return {case: \"unit\"};\n    case \"variable\": return term.type;\n    case \"abstraction\": return term.type;\n    case \"application\": return term.type;\n    case \"hole\": return term.type;\n  }\n}\n\nexport function extractHoleType(termAnn: TermAnn, holeId: HoleId): Type {\n  let type: Type | undefined = undefined;\n  function go(termAnn: TermAnn): void {\n    switch (termAnn.case) {\n      case \"unit\": return;\n      case \"variable\": return;\n      case \"abstraction\": go(termAnn.body); return;\n      case \"application\": go(termAnn.applicant); go(termAnn.argument); return;\n      case \"hole\": type = termAnn.type;\n    }\n  }\n  go(termAnn);\n  if (type !== undefined)\n    return type;\n  else\n    throw new Error(`hole id ${holeId} not found`);\n}","import { toArray } from \"./data/List\";\nimport { HoleId, holeIdToString, Term, termToString, Type, typeToString, VariableId, variableIdToString } from \"./language/Syntax\";\nimport { collectHoleContexts, Context, contextToString, infer, Inference, extractHoleType } from \"./Typing\";\n\nexport type State = {\n  term: Term;\n  type: Type;\n  focus: Focus | undefined;\n};\n\nexport type Focus = {\n  id: HoleId;\n  type: Type;\n  context: Context;\n  transitions: Transition[]; \n}\n\nexport type Transition\n  = { case: \"select\"; id: HoleId; }\n  | { case: \"put\"; put: Put }\n;\n\nexport type Put\n  = { case: \"unit\" }\n  | { case: \"variable\"; id: VariableId }\n  | { case: \"abstraction\" }\n  | { case: \"application\" }\n\nexport function stateToString(state: State): string {\n  return `term: ${termToString(state.term)}; type: ${typeToString(state.type)}; focus: ${focusToString(state.focus)}`;\n}\n\nexport function focusToString(focus: Focus | undefined): string {\n  if (focus !== undefined) {\n    return `id: ${focus.id}; type: ${typeToString(focus.type)}; context: ${contextToString(focus.context)}; transitions: ${focus.transitions.map(t => transitionToString(t)).join(\", \")}`;\n  } else \n    return \"unfocussed\"\n}\n\nexport function transitionToString(transition: Transition): string {\n  switch (transition.case) {\n    case \"select\": {\n      return `select hole id ${transition.id}`;\n    }\n    case \"put\": {\n      return `put ${putToString(transition.put)}`;\n    }\n  }\n}\n\nexport function putToString(put: Put): string {\n  switch (put.case) {\n    case \"unit\": return `unit`;\n    case \"variable\": return variableIdToString(put.id);\n    case \"abstraction\": return `λ ?`;\n    case \"application\": return `? ?`;\n  }\n}\n\n// Update\n\nexport function update(state: State, transition: Transition): State {\n  console.log(`update`);\n  console.log(`input state: ${stateToString(state)}`);\n  console.log(`transition: ${transitionToString(transition)}`);\n\n  switch (transition.case) {\n    case \"select\": {\n      // Infer hole type and context\n      let inference: Inference = infer(state.term);\n      let holeType: Type = extractHoleType(inference.termAnn, transition.id);\n      let holeContexts: Map<HoleId, Context> = collectHoleContexts(inference.termAnn);\n      {\n        let arr: string[] = [];\n        holeContexts.forEach((context, id) => arr.push(`${holeIdToString(id)}: ${contextToString(context)}`));\n        console.log(`holeContexts: ${arr.join(\"; \")}`);\n      }\n      let holeContext: Context;\n      {\n        let res = holeContexts.get(transition.id);\n        if (res !== undefined)\n          holeContext = res;\n        else {\n          throw new Error(`hole id ${transition.id} not found among hole contexts`);\n        }\n      }\n      console.log(`holeContext: ${contextToString(holeContext)}`);\n\n      // Collect transitions\n      let transitions: Transition[] = [];\n      let putOptions: Put[] = [];\n      // Basic constructors\n      putOptions.push({case: \"unit\"});\n      putOptions.push({case: \"application\"});\n      putOptions.push({case: \"abstraction\"});\n      // Variable constructors\n      toArray(holeContext).forEach((type, id) =>\n        putOptions.push({case: \"variable\", id})\n      );\n      putOptions.forEach(put => {\n        let fillTerm: Term;\n        switch (put.case) {\n          case \"unit\": fillTerm = {case: \"unit\"}; break;\n          case \"variable\": fillTerm = {case: \"variable\", id: put.id}; break;\n          case \"abstraction\": fillTerm = {case: \"abstraction\", body: {case: \"hole\", id: -1}}; break;\n          case \"application\": fillTerm = {case: \"application\", applicant: {case: \"hole\", id: -1}, argument: {case: \"hole\", id: -1}}; break;\n        }\n        console.log(`trying to fillHole ${termToString(state.term)}`);\n        let term: Term = fillHole(state.term, transition.id, fillTerm);\n        console.log(`trying to enumerate ${termToString(term)}`);\n        term = enumerateHoles(term);\n        try {\n          console.log(`trying to infer ${termToString(term)}`);\n          infer(term);\n          console.log(`success for ${termToString(term)}`);\n          // if succeeds, then add\n          transitions.push({case: \"put\", put});\n        } catch (e) {\n          console.log(`${putToString(put)} is an invalid \"put\" option because: ${e}`);\n          // pass\n        }\n      });\n\n      // New state\n      return {\n        term: state.term,\n        type: inference.type,\n        focus: {\n          id: transition.id,\n          type: holeType,\n          context: holeContext,\n          transitions\n        }\n      };\n    }\n    case \"put\": {\n      // must have focus in order to \"put\"\n      let focus: Focus = state.focus as Focus;\n      let fillTerm: Term;\n      switch (transition.put.case) {\n        case \"unit\": fillTerm = {case: \"unit\"}; break;\n        case \"variable\": fillTerm = {case: \"variable\", id: transition.put.id}; break;\n        case \"abstraction\": fillTerm = {case: \"abstraction\", body: {case: \"hole\", id: -1}}; break;\n        case \"application\": fillTerm = {case: \"application\", applicant: {case: \"hole\", id: -1}, argument: {case: \"hole\", id: -1}}; break;\n      }\n      let term: Term = fillHole(state.term, focus.id, fillTerm);\n      term = enumerateHoles(term);\n      let inference: Inference = infer(term);\n      return {\n        term,\n        type: inference.type,\n        focus: undefined,\n      };\n    }\n  }\n\n  throw new Error(\"unimplemented\");\n}\n\nexport function fillHole(term: Term, id:HoleId, termFill: Term): Term {\n  switch (term.case) {\n    case \"unit\": return term;\n    case \"variable\": return term;\n    case \"abstraction\": return {case: \"abstraction\", body: fillHole(term.body, id, termFill)};\n    case \"application\": return {case: \"application\", applicant: fillHole(term.applicant, id, termFill), argument: fillHole(term.argument, id, termFill)};\n    case \"hole\": {\n      if (term.id === id)\n        return termFill;\n      else \n        return term;\n    }\n  }\n}\n\nexport function enumerateHoles(term: Term): Term {\n  let freshHoleId = 0;\n  function freshHole(): Term {\n    let term: Term = {case: \"hole\", id: freshHoleId};\n    freshHoleId++;\n    return term;\n  }\n  function go(term: Term): Term {\n    switch (term.case) {\n      case \"unit\": return term;\n      case \"variable\": return term;\n      case \"abstraction\": return {case: \"abstraction\", body: go(term.body)};\n      case \"application\": return {case: \"application\", applicant: go(term.applicant), argument: go(term.argument)};\n      case \"hole\": return freshHole();\n    }\n  }\n  return go(term);\n}","import React, { MouseEventHandler } from 'react';\nimport './App.css';\nimport { toArray } from './data/List';\nimport { holeIdToString, Term, termToString, typeToString, variableIdToString } from './language/Syntax';\nimport { Put, putToString, State, Transition, transitionToString, update } from './State';\n\nexport type AppProperties = {};\n\nexport default class App extends React.Component<AppProperties, State> {\n  state: State = {\n    term: {case: \"hole\", id: 0},\n    type: {case: \"variable\", id: 0},\n    focus: undefined\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        {this.viewConsole()}\n        <hr />\n        {this.viewGoal()}\n        <hr />\n        {this.viewContext()}\n        <hr />\n        {this.viewPalette()}\n      </div>\n    );\n  }\n  \n  viewContext(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let variableViews: JSX.Element[] = [];\n      toArray(this.state.focus.context).forEach((type, id) =>\n        variableViews.push(\n          <div className=\"context-variable\">\n            {variableIdToString(id)}: {typeToString(type)}\n          </div>)\n      );\n      return (\n        <div className=\"context\">\n          Context: {variableViews}\n        </div>\n      );\n    } else\n      return (<div></div>);\n  }\n  \n  viewGoal(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      return (\n        <div className=\"goal\">\n          Goal: {typeToString(this.state.focus.type)}\n        </div>\n      );\n    } else\n    return (<div></div>);\n  }\n  \n  viewConsole(): JSX.Element {\n    let app = this;\n    function go(term: Term): JSX.Element {\n      switch (term.case) {\n        case \"unit\": return <span>{termToString(term)}</span>;\n        case \"variable\": return <span>{termToString(term)}</span>;\n        case \"abstraction\": {\n          let bodyView = go(term.body);\n          return (<span>(λ {bodyView})</span>);\n        }\n        case \"application\": {\n          let applicantView = go(term.applicant);\n          let argumentView = go(term.argument);\n          return (<span>({applicantView} {argumentView})</span>);\n        }\n        case \"hole\": {\n          let onClick: MouseEventHandler = e => app.setState(update(app.state, {case: \"select\", id: term.id}));\n          let className = app.state.focus !== undefined && app.state.focus.id === term.id ? \"hole focussed\" : \"hole\";\n          return (<span className={className} onClick={onClick}>{holeIdToString(term.id)}</span>);\n        }\n      }\n    }\n    return (\n      <div className=\"console\">\n        {go(this.state.term)} : {typeToString(this.state.type)}\n      </div>\n    )\n  }\n  \n  viewPalette(): JSX.Element {\n    if (this.state.focus !== undefined) {\n      let app = this;\n      let palleteItemViews: JSX.Element[] = [];\n\n      this.state.focus.transitions.forEach((transition) => {\n        switch (transition.case) {\n          case \"select\": break;\n          case \"put\": {\n            let onClick: MouseEventHandler = e => app.setState(update(app.state, transition));\n            palleteItemViews.push(\n              <div className=\"palette-item\" onClick={onClick}>\n                {putToString(transition.put)}\n              </div>\n            );\n          }\n        }\n      })\n      return (\n        <div className=\"palette\">\n          {palleteItemViews}\n        </div>\n      );\n    } else {\n      return (<div></div>);\n    }\n    \n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}